#!/usr/bin/perl
# dynamic_dns
#
# Purpose: This scripts job is read text files generated by one of four different
# methods, PWRUTC DB, SuperPing, standalone text files by Admins, or Menu Mode. These 
# text files will be used to dynamical update DNS.

# Written By: Jon Swift 08/05

# Misc. Variables
require 'getopts.pl';
$PID=$$;
$DOMAIN_NAME="pwrutc.com";
$WEB_DB_DIR="/local/data/DB_Updates";
$MASTER_DNS_SERVER="172.19.128.5";
$DOMAINS="pwrutc.com|testpwrutc.local|eh.pweh.com|rdyne.bna.boeing.com|sw.nos.boeing.com|se.nos.boeing.com";
$NSUPDATE_SERVER="pwr-dns-backup";
$EMAIL_ADDRESS="jsswift, aclessin, smarten";
$DELETE_RECORDS="/tmp/Delete_Records.$PID";
$ADD_RECORDS="/tmp/Add_Records.$PID";
$SUPER_PING_DIR="/local/data/SuperPing";
$SP_DELETE_RECORDS="$SUPER_PING_DIR/Delete_Record";
$INTERACTIVE_FILE="/tmp/InterActive";
$TTL="1200";
chomp ($HOST=`uname -n`);
chomp ($PROG=`basename $0`);
chomp ($OS=`uname -s`);
chomp($TIME=`date '+%H:%M'`);

# Use the standard subroutine Getopts to parse the arguments from the command line to this script
&Getopts("f:dhmst:") or &USAGE;

# Set INTERACTIVE to YES if this script is being run from the command line
$STATUS=system("/bin/sh -c /usr/bin/tty -s 1> /dev/null");
if ( "$STATUS" == 0 ) {
	$INTERACTIVE="YES";
} else {
	$INTERACTIVE="NO";
}

###############################################################
# System and User Check Section
###############################################################

# Confirm $PROG is run on a supported platform 
# and Set variables based on OS type
if ( "$OS" eq "Linux" ) {

	chomp($WHOAMI=`/usr/bin/whoami`);
	$MAIL="/bin/mail";
	$NSUPDATE="/usr/bin/nsupdate";
	$NSLOOKUP="/usr/bin/nslookup";
	$LOG="/var/log/ddns";

} elsif  ( "$OS" eq "SunOS" ) {

	chomp($WHOAMI=`/usr/ucb/whoami`);
	$MAIL="/bin/mailx";
	$NSUPDATE="/usr/sbin/nsupdate";
	$NSLOOKUP="/usr/sbin/nslookup";
	$LOG="/var/adm/ddns";

} else {
	print "\nError: $PROG not supported on $OS\n\n";
	exit 1;
} 

# Make sure this script is run as root
if ( "$WHOAMI" ne "root" ) {
	print "\nError: $PROG must be run as root\n";
	exit 1;
}
	
# Make sure the OS $NSUPDATE command exists
if ( ! -x $NSUPDATE ) {
	print "\n\nError: $PROG not supported on $HOST, the nsupdate command is not installed\n";
	exit 1;
}

###############################################################
#
# The following sections are used by the multiple 
# command line options to this script
#
###############################################################

###############################################################
# TTL Value Section
###############################################################
if ( $opt_t ) {

	# Make sure that $opt_t is defined as a number
	if ( "$opt_t" =~ m/\D/ ) {
		print "\nError: The argument to -t must be a number\n\n";
		exit 1;
	}

	# Set TTL to $opt_t
	$TTL="$opt_t";
}

###############################################################
# Manual File Section
###############################################################
if ( $opt_f ) {

	# Make sure this is the only option selected
	if ( $opt_s or $opt_d or $opt_m or $opt_h ) {
		print "\nError: $PROG does not support using multiple options at the same time\n";
		exit 1;
	}

	# Set the SYNTAX flag
	$SYNTAX="OK";

	# Make sure that Manual update file exists
	if ( ! -r $opt_f ) {
		print "\nError: The Manual update file $opt_f does not exist or is not readable\n\n";
		exit 1;
	}

	# Set $REMOVE to YES
	# REMOVE is used to control whether or not the ADD_RECORDS and DELETE_RECORDS file is deleted
	$REMOVE="YES";

	# Build list of records to be deleted from the file $DELETE_RECORDS
	&DELETE("$opt_f");

	# Build list of records to be added from the file $ADD_RECORDS
	&ADD("$opt_f");
}

###############################################################
# DB (DNS Data Base) Section
###############################################################
if ( $opt_d ) {

	# Make sure this is the only option selected
	if ( $opt_s or $opt_f or $opt_m or $opt_h ) {
		print "\nError: $PROG does not support using multiple options at the same time\n";
		exit 1;
	}

	# Set the SYNTAX flag
	$SYNTAX="OK";

	# Make sure this script is being run only on $NSUPDATE_SERVER
	&HOST_CHK;

	# Make sure that $WEB_DB_DIR exists
	if ( ! -d "$WEB_DB_DIR" ) {
		print "\nError: The required Web Based DB directory $WEB_DB_DIR does not exist\n\n";
		exit 1;
	}

	# Remove any file named export.ini
	( -f "$WEB_DB_DIR/export.ini" ) and unlink "$WEB_DB_DIR/export.ini";

	# Set $REMOVE to YES
	# REMOVE is used to control whether or not the ADD_RECORDS and DELETE_RECORDS file is deleted
	$REMOVE="YES";

	# Use each file in the directory $WEB_DB_DIR to build the list of records to add and delete
	opendir (WEB_DB_DIR,"$WEB_DB_DIR") or die "Error: Unable to open the directory $WEB_DB_DIR: $!\n";	

	WEB_DB: while ($FILE_NAME = readdir(WEB_DB_DIR)) {

		# if $FILE_NAME is equal to a dot "." or dot dot ".." skip this file name
		( "$FILE_NAME" eq '.' or "$FILE_NAME" eq '..'  ) and next WEB_DB;

		# ReSet $FILE_NAME to be $WEB_DB_DIR/$FILE_NAME
		$FILE_NAME="$WEB_DB_DIR/$FILE_NAME";

		# Remove any files that are zero sized
		if ( -z "$FILE_NAME" ) { 
			unlink $FILE_NAME;
			next WEB_DB;
		}

		# Build list of records to be deleted from the file $DELETE_RECORDS
		&DELETE("$FILE_NAME");

		# Build list of records to be added from the file $ADD_RECORDS
		&ADD("$FILE_NAME");

		# Wait 10 seconds to allow the ADD function to complete
		sleep 10;
		
		# Remove the file $FILE_NAME
		( -f "$FILE_NAME" ) and unlink "$FILE_NAME";

		# Set $REMOVE to NO
		# REMOVE is used to control whether or not the ADD_RECORDS and DELETE_RECORDS file is deleted
		$REMOVE="NO";
	}

	# Close the directory handle WEB_DB_DIR
	closedir(WEB_DB_DIR);
}

###############################################################
# Menu Mode Section
###############################################################
if ( $opt_m ) {

	# Make sure this is the only option selected
	if ( $opt_s or $opt_f or $opt_d or $opt_h ) {
		print "\nError: $PROG does not support using multiple options at the same time\n";
		exit 1;
	}

	# Set the SYNTAX flag
	$SYNTAX="OK";

	# Present Menu
	system("clear");

	# Display message
	print "\n\n###################\n";
	print "     MENU MODE\n";
	print "###################\n\n";
	
	# Display message
	print "Select one of the following\n";

	# Loop through menu until a valid Selection is made
	TOP: while ( "$VALID" ne "VALID" ) {

		print "1> Add a record to DNS\n";
		print "2> Delete a record from DNS\n";
		print "Enter Choice > ";

		# Read in responce
		while (<STDIN>) {

			# Remove EOL character
        		chomp $_;
		
			# Add Record
			if ( "$_" == 1 ) {

				# Display message
				print "\n\n###################\n";
				print "   ADD A RECORD\n";
				print "###################\n\n";
				print "Select one of the following\n";

				ADD: while ( "$VALID" ne "VALID" ) {

					print "1> Add a \"Host\"/\"A\" record to DNS\n";
					print "2> Add a \"PTR\" record to DNS\n";
					print "3> Add a \"CNAME\" record to DNS\n";
					print "Enter Choice > ";

					# Read in responce
					while (<STDIN>) {

						# Remove EOL character
        					chomp $_;

						# A Record
						if ( "$_" == 1 ) {
							$RECORD_TYPE="A";
							&ADD_MENU;
							$VALID="VALID";

						# PTR Record
						} elsif ( "$_" == 2 ) {
							$RECORD_TYPE="PTR";
							&ADD_MENU;
							$VALID="VALID";

						# CNAME Record
						} elsif ( "$_" == 3 ) {
							$RECORD_TYPE="CNAME";
							&ADD_MENU;
							$VALID="VALID";
	
						# Blank Line
						} elsif ( "$_" eq "" ) {
							print "\n";
							next ADD;

						# Quit
						} elsif ( "$_" eq "q" or "$_" eq "Q" ) {
							print "\n";
							close(STDIN);
							exit 1;

						# Error
						} else {
							print "\nInvalid Selection, $_\n";
							next ADD;
						}
					}
				}

				# Add record to DNS
				( -s $INTERACTIVE_FILE ) and &ADD("$INTERACTIVE_FILE");

			# Delete Record
			} elsif ( "$_" == 2 ) {

				# Display message
				print "\n\n###################\n";
				print "  DELETE A RECORD\n";
				print "###################\n\n";
				print "Select one of the following\n";

				DELETE: while ( "$VALID" ne "VALID" ) {

					print "1> Delete a \"Host\"/\"A\" record from DNS\n";
					print "2> Delete a \"PTR\" record from DNS\n";
					print "3> Delete a \"CNAME\" record from DNS\n";
					print "4> Delete a \"TXT\" record from DNS\n";
					print "Enter Choice > ";
	
					# Read in responce
					while (<STDIN>) {

						# Remove EOL character
        					chomp $_;

						# A Record
						if ( "$_" == 1 ) {
							$RECORD_TYPE="A";
							&DELETE_MENU;
							$VALID="VALID";

						# PTR Record
						} elsif ( "$_" == 2 ) {
							$RECORD_TYPE="PTR";
							&DELETE_MENU;
							$VALID="VALID";

						# CNAME Record
						} elsif ( "$_" == 3 ) {
							$RECORD_TYPE="CNAME";
							&DELETE_MENU;
							$VALID="VALID";

						# TXT Record
						} elsif ( "$_" == 4 ) {
							$RECORD_TYPE="TXT";
							&DELETE_MENU;
							$VALID="VALID";
	
	
						# Blank Line
						} elsif ( "$_" eq "" ) {
							print "\n";
							next DELETE;

						# Quit
						} elsif ( "$_" eq "q" or "$_" eq "Q" ) {
							print "\n";
							close(STDIN);
							exit 1;

						# Error
						} else {
							print "\nInvalid Selection $_\n";
							next DELETE;
						}
					}
				}

				# Delete record to DNS
				( -s $INTERACTIVE_FILE ) and &DELETE("$INTERACTIVE_FILE");

			# Null, just a CR
			} elsif ( "$_" eq "" ) {
				print "\n";
				next TOP;

			# Quit
			} elsif ( "$_" eq "q" or "$_" eq "Q" ) {
				print "\n";
				close(STDIN);
				exit 1;

			# Error
			} else {
				print "\nInvalid Selection, $_\n";
				print "\n";
				next TOP;
			}
		}
	
		# Remove the file $INTERACTIVE_FILE if it exists
		( -f $INTERACTIVE_FILE ) and unlink $INTERACTIVE_FILE;
	}
}

###############################################################
# SuperPing Section
###############################################################
if ( $opt_s ) {

	# Make sure this is the only option selected
	if ( $opt_m or $opt_f or $opt_d or $opt_h ) {
		print "\nError: $PROG does not support using multiple options at the same time\n";
		exit 1;
	}

	# Set the SYNTAX flag
	$SYNTAX="OK";

	# Make sure this script is being run only on $NSUPDATE_SERVER
	&HOST_CHK;

	# Set $REMOVE to YES
	# REMOVE is used to control whether or not the ADD_RECORDS and DELETE_RECORDS file is deleted
	$REMOVE="YES";

	# Make sure the SuperPing SP_DELETE_RECORDS file exists
	if ( -s $SP_DELETE_RECORDS ) {

		# Build list of records to be deleted from the file $SP_DELETE_RECORDS
		&DELETE("$SP_DELETE_RECORDS");

		# Wait 10 seconds to allow the DELETE function to complete
		sleep 10;
		
		# Remove the file $SP_DELETE_RECORDS
		unlink "$SP_DELETE_RECORDS";
	}
}

###############################################################
# Help Section
###############################################################
if ( $opt_h ) {

	# Make sure this is the only option selected
	if ( $opt_m or $opt_f or $opt_d or $opt_s ) {
		print "\nError: $PROG does not support using multiple options at the same time\n";
		exit 1;
	}

	# Set the SYNTAX flag
	$SYNTAX="OK";

	print "\n\n\tThe \"$PROG\" script is used to dynamical add or remove entries from DNS
using the OS command \"nsupdate\". $PROG will add both the \"A\" and \"PTR\" records
when ask to add just the \"A\" record. It will also remove both the \"A\" and \"PTR\" records
when asked to delete just the \"A\" record. Using the -f option requires that a file name be
supplied. This file contains the information on what to add or delete, and must be formated
correctly. Each system/IP to be added or removed must be on it's own line.  And each line must
have all the information in the correct order. To \"add\" new records to the DNS use the 
following format. If the DNS record to be added is in DNS domain ${DOMAIN_NAME} the domain 
name does need to be included with the HostName.

###############################################################
#	Add Record Examples
###############################################################

#  HostName SupportData Record-Type Add
print-server.${DOMAIN_NAME} 172.19.130.XXX A Add
print-server.${DOMAIN_NAME} 172.19.130.XXX PTR Add
printhost.${DOMAIN_NAME} print-server.${DOMAIN_NAME} CNAME Add
print-server 172.19.130.XXX A Add
print-server 172.19.130.XXX PTR Add
printhost print-server CNAME Add

	To remove records from DNS use the following format. If the DNS record to be removed 
is in DNS domain ${DOMAIN_NAME} the domain name does need to be included with the HostName.

###############################################################
#	Delete Record Examples
###############################################################

# HostName/IP Record-Type Delete
print-server.${DOMAIN_NAME} 172.19.130.XXX A Delete
printhost.${DOMAIN_NAME} print-server.${DOMAIN_NAME} CNAME Delete
printhost.${DOMAIN_NAME} 172.19.XXX.XXX PTR Delete
ex123456.${DOMAIN_NAME} 31f35be2b77070ac0e325eb2bb1c1d752c TXT Delete
print-server 172.19.130.XXX A Delete
printhost print-server CNAME Delete
printhost 172.19.XXX.XXX PTR Delete
ex123456 31f35be2b77070ac0e325eb2bb1c1d752c TXT Delete\n\n\n";

	exit 1;
}

# Make sure the command syntax used was correct
( "$SYNTAX" ne "OK" ) and &USAGE;

# If either $DELETE_RECORDS or $ADD_RECORDS exist make sure $MASTER_DNS_SERVER is up
if ( -s $DELETE_RECORDS or -s $ADD_RECORDS ) {

	# ping $MASTER_DNS_SERVER
	&PING("$MASTER_DNS_SERVER");
	if ( $PING_STATUS == 1 ) {

		# Set ERROR_MESSAGE to message that will be sent if the master DNS server id down
		&DATE;
		my $ERROR_MESSAGE="Error $DATE_TIME: The Master DNS server $MASTER_DNS_SERVER is down, unable to continue\n";

		# Send email and log $ERROR_MESSAGE
		&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
		sleep 10;
		exit 0;
	}
}

# Check for the file $DELETE_RECORDS, 
# if it exists run nsupadte using $DELETE_RECORDS as the source for nsupdate
if ( -s $DELETE_RECORDS ) {

	# Redirect standard error to $LOG for non INTERACTIVE users
	if ( "$INTERACTIVE" eq "YES" ) {

		# Remove all records in $DELETE_RECORDS file using the OS command nsupdate
		system("$NSUPDATE $DELETE_RECORDS");
	} else {

		# Remove all records in $DELETE_RECORDS file using the OS command nsupdate
		system("$NSUPDATE $DELETE_RECORDS 2>>$LOG");
	}
}

# Check for the file $ADD_RECORDS, 
# if it exists run nsupadte using $ADD_RECORDS as the source for nsupdate
if ( -s $ADD_RECORDS ) {

	# Redirect standard error to $LOG for non INTERACTIVE users
	if ( "$INTERACTIVE" eq "YES" ) {

		# Add all records in $ADD_RECORDS file using the OS command nsupdate
		system("$NSUPDATE $ADD_RECORDS");
	} else {

		# Add all records in $ADD_RECORDS file using the OS command nsupdate
		system("$NSUPDATE $ADD_RECORDS 2>>$LOG");
	}	
}

# Remove the $ADD_RECORDS file
( -f $ADD_RECORDS ) and unlink $ADD_RECORDS;

# Remove the $DELETE_RECORDS file
( -f $DELETE_RECORDS ) and unlink $DELETE_RECORDS; 

###############################################################
# The function DELETE is used to build the file $DELETE_RECORDS
# The file $DELETE_RECORDS holds all records that need to be 
# deleted. After the file is created DELETE runs nsupdate using 
# the file $DELETE_RECORDS.
###############################################################
sub DELETE {

	# Set $FILE file name supplied to this function
	my ($FILE)=@_;

	# Set ERROR_MESSAGE to message that will be sent if Unable to open the file $FILE
	&DATE;
	my $ERROR_MESSAGE="Error $DATE_TIME: Unable to open the file $FILE on $HOST\n"; 

	# Open the file handle FILE to read in $FILE
	open(FILE,"$FILE") or &ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE") and die;

	# Remove $DELETE_RECORDS if it exists and if $REMOVE is set to YES
	( -f $DELETE_RECORDS and "$REMOVE" eq "YES" ) and unlink $DELETE_RECORDS;

	# Set ERROR_MESSAGE to message that will be sent if Unable to open the file $DELETE_RECORDS
	&DATE;
	$ERROR_MESSAGE="Error $DATE_TIME: Unable to open the file $DELETE_RECORDS on $HOST\n";

	# Open the file $DELETE_RECORDS
	open (DELETE_RECORDS,">>$DELETE_RECORDS") or &ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE") and die;

	# Look for the key word delete, any lines containing the word delete as the last word should be added to @DELETE
	FILE1: while (<FILE>) {
		
		# Remove end of line character
		chomp $_;

		# Skip blank lines
		( $_ =~ m/^$/ ) and next FILE1;

		# Convert any commas to spaces and remove double quotes
		$_=~s/,/ /g;
		$_=~s/\"//g;
		
		# The key word delete must have a leading space and must be followed by the end of line
		# The case of delete does not matter
		if ( $_ =~ m/\s+delete$|\s+delete\s+$/i ) {

			# Confirm the line is formatted properly

			# There should be 4 fields, 
			# The first fieled is the Host Name, 
			# The second field is Support Data, either IP address or alias host name
			# Third field is record type, 
			# Fourth field is the keyword delete	
			# Break the line into four variables, $HOST_NAME, $SUPPORT_DATA, $RECORD_TYPE, $FUNCTION
			($HOST_NAME, $SUPPORT_DATA, $RECORD_TYPE, $FUNCTION)=(split/\s+/,$_);

			# Set ERROR_MESSAGE to message that will be sent if line is not formatted properly
			&DATE;
			my $ERROR_MESSAGE="Error $DATE_TIME: The \"delete\" line \"$_\" not formatted properly\n";

			# Confirm each variable is properly set 
			if ( "$HOST_NAME" eq "" ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( "$SUPPORT_DATA"  eq "" ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( "$RECORD_TYPE"  eq "" or "$RECORD_TYPE" !~ m/A|CNAME|PTR|TXT/i ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( "$FUNCTION" eq "" or "$FUNCTION" !~ m/delete/i ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;
			}

			# Correct Case on the following variables
			$RECORD_TYPE=~tr/a-z/A-Z/;
			$FUNCTION=~tr/A-Z/a-z/;
			$HOST_NAME=~tr/A-Z/a-z/;
			( "$RECORD_TYPE" ne "TXT" ) and $SUPPORT_DATA=~tr/A-Z/a-z/;

			if ( "$RECORD_TYPE" eq "A" and "$SUPPORT_DATA" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( "$RECORD_TYPE" eq "PTR" and "$SUPPORT_DATA" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( "$RECORD_TYPE" eq "CNAME" and "$SUPPORT_DATA" =~ m/\d+\.\d+\.\d+\.\d+/ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( "$RECORD_TYPE" eq "TXT" and "$SUPPORT_DATA" !~ m/................................../ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;
			}

			# Determine if $HOST_NAME is using FQN name, add $DOMAIN_NAME to $HOST_NAME as needed
			if ( $HOST_NAME =~ m/\./ and $HOST_NAME !~ m/$DOMAINS/i ) {

				# Set ERROR_MESSAGE to message that will be sent if line has unsupported/invalid domain name
				&DATE;
				my $ERROR_MESSAGE=" Error $DATE_TIME: The Host Name in \"delete\" line \"$_\" has Invalid domain name\n";

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE1;

			} elsif ( $HOST_NAME !~ m/\./ ) {

				# $HOST_NAME to fully FQN name
				$HOST_NAME="$HOST_NAME.$DOMAIN_NAME";
			}

			# A Record and CNAME Record Section only
			if ( "$RECORD_TYPE" eq "A" or "$RECORD_TYPE" eq "CNAME" ) {

				# Determine if $SUPPORT_DATA is using FQN name, add $DOMAIN_NAME to $SUPPORT_DATA as needed
				if ( "$RECORD_TYPE" eq "CNAME" and $SUPPORT_DATA =~ m/\./ and $SUPPORT_DATA !~ m/$DOMAINS/i ) {

					# Set ERROR_MESSAGE to message that will be sent if line has unsupported/invalid domain name
					&DATE;
					my $ERROR_MESSAGE=" Error $DATE_TIME: The Host Name in \"delete\" line \"$_\" has Invalid domain name\n";

					# Send email and log $ERROR_MESSAGE
					&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
					next FILE1;

				} elsif ( "$RECORD_TYPE" eq "CNAME" and $SUPPORT_DATA !~ m/\./ ) {

					# $SUPPORT_DATA to fully FQN name
					$SUPPORT_DATA="$SUPPORT_DATA.$DOMAIN_NAME";
				}

				# Add Prerequisite,  Make sure the record exists
				print DELETE_RECORDS "prereq yxrrset $HOST_NAME $RECORD_TYPE\n";
			
				# Add line to $DELETE_RECORDS
				print DELETE_RECORDS "update $FUNCTION $HOST_NAME $RECORD_TYPE\n";

				# Set LOG_MESSAGE to message that will be  be logged to $LOG_MESSAGE then log it
				&DATE;
				my $LOG_MESSAGE="$HOST $DATE_TIME: Deleting $RECORD_TYPE Record $HOST_NAME\n";
				&LOG("$LOG_MESSAGE");

				# Add blank line, the blank line forces nsupdate to send the update packets to the DNS server 
				print DELETE_RECORDS "\n";
			}

			# Remove the reverse record if $RECORD_TYPE is set to A or PTR
			if ( "$RECORD_TYPE" eq "A" or "$RECORD_TYPE" eq "PTR" ) {

				# Confirm $SUPPORT_DATA is set
				if ( "$SUPPORT_DATA" ne "" ) {

					# Set $REV_SUPPORT_DATA to $SUPPORT_DATA
					$REV_SUPPORT_DATA="$SUPPORT_DATA";

					# Reverse the fields in the IP address of $REV_SUPPORT_DATA
					($FIRST, $SECOND, $THIRD, $FOURTH)=(split/\./,$REV_SUPPORT_DATA);

					# Reset $REV_SUPPORT_DATA
					$REV_SUPPORT_DATA="$FOURTH.$THIRD.$SECOND.$FIRST.in-addr.arpa";

					# Add Prerequisite, Make sure $REV_SUPPORT_DATA is in DNS
					print DELETE_RECORDS "prereq yxrrset $REV_SUPPORT_DATA PTR\n";

					# Add line to $DELETE_RECORDS
					print DELETE_RECORDS "update $FUNCTION $REV_SUPPORT_DATA PTR\n";

					# Set LOG_MESSAGE to message that will be  be logged to $LOG_MESSAGE then log it
					&DATE;
					my $LOG_MESSAGE="$HOST $DATE_TIME: Deleting PTR Record $HOST_NAME $REV_SUPPORT_DATA\n";
					&LOG("$LOG_MESSAGE");

					# Add blank line, the blank line forces nsupdate to send the update packets to the DNS server 
					print DELETE_RECORDS "\n";

				} elsif ( "$SUPPORT_DATA" eq "" ) {

					&DATE;
					my $ERROR_MESSAGE="Error $DATE_TIME: The HostName in \"delete\" line \"$_\" Invalid, Not deleting $HOST_NAME\n";

					# Send email and log $ERROR_MESSAGE
					&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				}
			}

			# Remove the text record if $RECORD_TYPE is set to TXT
			if ( "$RECORD_TYPE" eq "TXT" ) {

				# Add Prerequisite, Make sure $REV_SUPPORT_DATA is in DNS
				print DELETE_RECORDS "prereq yxrrset $HOST_NAME TXT\n";

				# Add line to $DELETE_RECORDS
				print DELETE_RECORDS "update $FUNCTION $HOST_NAME TXT\n";

				# Set LOG_MESSAGE to message that will be  be logged to $LOG_MESSAGE then log it
				&DATE;
				my $LOG_MESSAGE="$HOST $DATE_TIME: Deleting TXT Record $HOST_NAME $SUPPORT_DATA\n";
				&LOG("$LOG_MESSAGE");

				# Add blank line, the blank line forces nsupdate to send the update packets to the DNS server 
				print DELETE_RECORDS "\n";
			}
		}
	}

	# Close the file handle FILE
	close(FILE);

	# Close the file handle DELETE_RECORDS
	close(DELETE_RECORDS);
1;
}

###############################################################
# The function ADD is used to build the file $ADD_RECORDS
# The file $ADD_RECORDS contains all records that need to be 
# added. After the file is created ADD runs "nsupdate" using
# the file $ADD_RECORDS.
###############################################################
sub ADD {

	# Set $FILE file name supplied to this function
	my ($FILE)=@_;

	# Set ERROR_MESSAGE to message that will be sent if unable to open $FILE
	&DATE;
	my $ERROR_MESSAGE="Error $DATE_TIME: Unable to open the file $FILE on $HOST\n";

	# Open the file handle FILE to read in $FILE
	open(FILE,"$FILE") or &ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE") and die;

	# Remove $ADD_RECORDS if it exists and if $REMOVE is set to YES
	( -f $ADD_RECORDS and "$REMOVE" eq "YES" ) and unlink $ADD_RECORDS;

	# Open the file $ADD_RECORDS
	$ERROR_MESSAGE="Error $DATE_TIME: Unable to open the file $ADD_RECORDS on $HOST\n";
	open (ADD_RECORDS,">>$ADD_RECORDS") or &ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE") and die;

	# Look for the key word add, any lines containing the word add as the last word should be added to the file $ADD_RECORDS
	FILE2: while (<FILE>) {
		
		# Remove end of line character
		chomp $_;

		# Skip blank lines
		( $_ =~ m/^$/ ) and next FILE2;

		# Convert any commas to spaces and remove double quotes
		$_=~s/,/ /g;
		$_=~s/\"//g;

		# The key word add must have a leading space and must be followed by the end of line877G
		# The case of add does not matter
		if ( $_ =~ m/\s+add$|\s+add\s+$/i ) {

			# Confirm the line is formatted properly

			# There should be 4 fields, 
			# The first fieled is the Host Name, 
			# The second field is Support Data, either IP address or alias host name
			# Third field is record type, 
			# Fourth field is the keyword add	
			# Break the line into four variables, $HOST_NAME, $SUPPORT_DATA, $RECORD_TYPE, $FUNCTION
			($HOST_NAME, $SUPPORT_DATA, $RECORD_TYPE, $FUNCTION)=(split/\s+/,$_);

			# Set ERROR_MESSAGE to message that will be sent if line is not formatted properly
			&DATE;
			my $ERROR_MESSAGE="Error $DATE_TIME: The \"add\" line \"$_\" not formatted properly\n";

			# Confirm each variable is properly set 
			if ( "$HOST_NAME" eq "" ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			} elsif ( "$SUPPORT_DATA"  eq "" ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			} elsif ( "$RECORD_TYPE"  eq "" or "$RECORD_TYPE" !~ m/A|CNAME|PTR/i ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			} elsif ( "$FUNCTION" eq "" or "$FUNCTION" !~ m/add/i ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;
			}

			# Correct Case on the following variables
			$RECORD_TYPE=~tr/a-z/A-Z/;
			$FUNCTION=~tr/A-Z/a-z/;
			$HOST_NAME=~tr/A-Z/a-z/;
			$SUPPORT_DATA=~tr/A-Z/a-z/;

			if ( "$RECORD_TYPE" eq "A" and "$SUPPORT_DATA" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			} elsif ( "$RECORD_TYPE" eq "PTR" and "$SUPPORT_DATA" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			} elsif ( "$RECORD_TYPE" eq "CNAME" and "$SUPPORT_DATA" =~ m/\d+\.\d+\.\d+\.\d+/ ) {

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			}

			# Determine if $HOST_NAME is using FQN name, add $DOMAIN_NAME to $HOST_NAME as needed
			if ( $HOST_NAME =~ m/\./ and $HOST_NAME !~ m/$DOMAINS/i ) {

				# Set ERROR_MESSAGE to message that will be sent if line has unsupported/invalid domain name
				&DATE;
				my $ERROR_MESSAGE="Error $DATE_TIME: The Host Name in \"add\" line \"$_\" has Invalid domain name\n";

				# Send email and log $ERROR_MESSAGE
				&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
				next FILE2;

			} elsif ( $HOST_NAME !~ m/\./ ) {

				# $HOST_NAME to fully FQN name
				$HOST_NAME="$HOST_NAME.$DOMAIN_NAME";
			}

			# Add the forward entry for a A records or a CNAME record
			if ( "$RECORD_TYPE" eq "A" or "$RECORD_TYPE" eq "CNAME" ) {

				# Determine if $SUPPORT_DATA is using FQN name, add $DOMAIN_NAME to $SUPPORT_DATA as needed
				if ( "$RECORD_TYPE" eq "CNAME" and $SUPPORT_DATA =~ m/\./ and $SUPPORT_DATA !~ m/$DOMAINS/i ) {

					# Set ERROR_MESSAGE to message that will be sent if line has unsupported/invalid domain name
					&DATE;
					my $ERROR_MESSAGE=" Error $DATE_TIME: The Host Name in \"add\" line \"$_\" has Invalid domain name\n";

					# Send email and log $ERROR_MESSAGE
					&ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE");
					next FILE2;

				} elsif ( "$RECORD_TYPE" eq "CNAME" and $SUPPORT_DATA !~ m/\./ ) {

					# $SUPPORT_DATA to fully FQN name
					$SUPPORT_DATA="$SUPPORT_DATA.$DOMAIN_NAME";
				}

				# Add the correct Prerequisite based on $RECORD_TYPE
				if ( "$RECORD_TYPE" eq "A" ) {

					# Add Prerequisite, Make sure $HOST_NAME is not already in DNS
					print ADD_RECORDS "prereq nxrrset $HOST_NAME $RECORD_TYPE\n";

				# CNAME records
				} else {

					# If $SUPPORT_DATA is in the same domain as $DOMAIN_NAME, Add
					#  a Prerequisite, that there is a A record for $SUPPORT_DATA
					# In this case $SUPPORT_DATA is the host name to add the alias/CNAME to
					# Add Check to see if $SUPPORT_DATA is part of $DOMAIN_NAME
					( $DOMAIN_NAME =~ m/$SUPPORT_DATA/ ) and print ADD_RECORDS "prereq yxrrset $SUPPORT_DATA A\n";
				}

				# Set LOG_MESSAGE to message that will be  be logged to $LOG_MESSAGE then log it
				&DATE;
				my $LOG_MESSAGE="$HOST $DATE_TIME: Adding $RECORD_TYPE Record $HOST_NAME $SUPPORT_DATA\n";
				&LOG("$LOG_MESSAGE");
			
				# Add line to $ADD_RECORDS
				print ADD_RECORDS "update $FUNCTION $HOST_NAME $TTL $RECORD_TYPE $SUPPORT_DATA\n";

				# Add blank line, the blank line forces nsupdate to send the update packets to the DNS server 
				print ADD_RECORDS "\n";
			}

			# Add the reverse record for new A records or just a PTR record
			if ( "$RECORD_TYPE" eq "A" or "$RECORD_TYPE" eq "PTR" ) {

				# Set $REV_SUPPORT_DATA to $SUPPORT_DATA
				$REV_SUPPORT_DATA="$SUPPORT_DATA";

				# Reverse the fields in the IP address of $REV_SUPPORT_DATA
				($FIRST, $SECOND, $THIRD, $FOURTH)=(split/\./,$REV_SUPPORT_DATA);

				# Reset $REV_SUPPORT_DATA with the ".in-addr.arpa extension"
				$REV_SUPPORT_DATA="$FOURTH.$THIRD.$SECOND.$FIRST.in-addr.arpa";

				# Add prereq for the add line, Make sure $REV_SUPPORT_DATA is not already in DNS
				print ADD_RECORDS "prereq nxrrset $REV_SUPPORT_DATA PTR\n";

				# Set LOG_MESSAGE to message that will be  be logged to $LOG_MESSAGE then log it
				&DATE;
				my $LOG_MESSAGE="$HOST $DATE_TIME: Adding PTR Record $REV_SUPPORT_DATA $HOST_NAME\n";
				&LOG("$LOG_MESSAGE");

				# Add delete update line to $ADD_RECORDS
				print ADD_RECORDS "update $FUNCTION $REV_SUPPORT_DATA $TTL PTR $HOST_NAME.\n";

				# Add blank line, the blank line forces nsupdate to send the update packets to the DNS server 
				print ADD_RECORDS "\n";

			}
		}
	}

	# Close the file handle FILE
	close(FILE);
	
	# Close the file handle ADD_RECORDS
	close(ADD_RECORDS);
1;
}

# Function to confirm this script is run from $NSUPDATE_SERVER/ correct server
sub HOST_CHK {
	if ( "$HOST" ne "$NSUPDATE_SERVER" ) {
		print "\nError: This feature of $PROG is only supported on $NSUPDATE_SERVER\n";
		exit 1;
	}
1;
}

# The ERROR_MAIL function is used to email/page server team members that there is a problem.
sub ERROR_EMAIL {

	# $EMAIL_MESSAGE is the body of the email
        my ($EMAIL_MESSAGE)=@_;

	# Prepare error message
        &DATE;
        my $ERROR="Error $DATE_TIME:  Can not open the $MAIL command";

	# Set email Subject
	$SUBJECT="$PROG Error on $HOST";

	# Open the mail command
        open (EMAIL,"|$MAIL -s \"$SUBJECT\" $EMAIL_ADDRESS") or &LOG("$ERROR");

	# Send the email
        print EMAIL "$EMAIL_MESSAGE";

	# Close the EMAIL file handle
        close (EMAIL) or &LOG("$ERROR\n");
1;
}

# The DATE function is used to set the $DATE_TIME variable
sub DATE {

        # Set DATE_TIME, DATE is used to hold the current date and time, (ie.. 08/05/05 09:57:32)
        chomp($DATE_TIME=`date '+%m/%d/%y %H:%M:%S'`);
1;
}

# The LOG function is used to write to LOG_FILE
sub LOG {

	# Prepare error message
        my ($LOG_MESSAGE)=@_;
	&DATE;
        my $ERROR_MESSAGE="Error $DATE_TIME: Can not open the log file, $LOG on $HOST\n";

        # Send email and log the error/status message
	open (LOG,">>$LOG") or &ERROR_EMAIL("$ERROR_MESSAGE");
    	print LOG "$LOG_MESSAGE";

	# Display message for interactive sessions
	( "$INTERACTIVE" eq "YES" ) and print "$LOG_MESSAGE";
        close (LOG);
1;
}

# Usage subroutine
sub USAGE {
	print "\n\n\t\"$PROG\" is used to add or delete records to/from DNS dynamicly.
	\n\tUsage:
	-f \"File Mode\"
	-s \"SuperPing Mode\"
	-d \"DataBase Mode\"
	-m \"Menu Mode\"
	-t \"TTL Value\"
	-h \"Help\"
	\n\n\t\####################
	\"Option Definitions\"
	####################
	 \"File Mode\" Reads from required file name argument supplied.
	 \"SuperPing Mode\" Reads from the file supplied by the \"SuperPing\" script.
	 \"DataBase Mode\" Reads from the file supplied by the DNS Data Base.
	 \"Menu Mode\" Menu driven method for Adding and Deleting records.
	 \"TTL Value\" Define TTL to the value of the argument supplied, default value is $TTL.
	 \"Help\" Provides information on the required input file format.\n\n";
	
	exit 1;
1;
}

# The Ping function is used to ping $HOSTNAME
sub PING {

	# Set $HOSTNAME to the argument supplied
 	my ($HOSTNAME)=@_;

	# Set $PING based on $OS
	if ( "$OS" eq "Linux" ) {
		$PING="/bin/ping -c2 -w1 $HOSTNAME | grep -c \'100% packet loss\' 1>/dev/null 2>&1";
	} else {
		$PING="/usr/sbin/ping -c2 $HOSTNAME 2 | grep -c \'no answer\' 1>/dev/null 2>&1";
	}

	# Display message for interactive sessions
	( "$INTERACTIVE" eq "YES" ) and print "\n\nPinging the DNS master $HOSTNAME to confirm it is up\n\n";
	
	# Set PING_STATUS, 1 = UP, 0 = Down
	$PING_STATUS=(system("/bin/sh -c \"$PING\""));
1;
}

# The ADD function is used to add either A or CNAME records to DNS
sub ADD_MENU {

	# Remove as needed $INTERACTIVE_FILE
	( -f $INTERACTIVE_FILE ) and unlink $INTERACTIVE_FILE;
	
	# Print blank line
	print "\n";

	ADD_NAME: while ( "$VALID" ne "VALID" ) {

		# Display proper message
		if  ( "$RECORD_TYPE" eq "CNAME" ) {
			print "Enter Alias name for new \"$RECORD_TYPE\" record > ";
		} else {
			print "Enter Host name for new \"$RECORD_TYPE\" record > ";
		}

		# Read in responce
		while (<STDIN>) {

			# Remove EOL character
        		chomp $_;

			# Confirm $_ is not a null
			( "$_" eq "" )  and next ADD_NAME;

			# Set ADD_NAME to $_ 
			$ADD_NAME="$_";

			 ADD_NAME1: while ( "$VALID" ne "VALID" ) {

				# Add "A" record section
				if ( "$RECORD_TYPE" eq "A" ) {

					print "Enter IP address for $ADD_NAME > ";

					# Read in responce
					while (<STDIN>) {
	
						# Remove EOL character
       						chomp $_;
	
						# Confirm $_ is not a null
						( "$_" eq "" ) and next ADD_NAME1;

						# Confirm that the IP address has 4 fields
						if ( "$_" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

							# Display error message
							print "\nError: $_ IP address is not formatted properly\n";
							exit 1;
					
						} else {
							$RRDATA="$_";
							$VALID="VALID";
							close(STDIN);
						}
					}

					# Confirm $RRDATA is not already being used in $DOMAIN_NAME
					&NSLOOKUP($RRDATA);
					if ( "$USED_NAME" eq "YES" ) {

						# Display error message
						print "\nError: The IP \"$RRDATA\" already exists in DNS, unable to add the A record for $ADD_NAME\n";
						exit 1;
					}

				# Add PTR record section
				} elsif ( "$RECORD_TYPE" eq "PTR" ) {

					print "Enter IP address for $ADD_NAME > ";

					# Read in responce
					while (<STDIN>) {
	
						# Remove EOL character
       						chomp $_;
	
						# Confirm $_ is not a null
						( "$_" eq "" ) and next ADD_NAME1;

						# Confirm that the IP address has 4 fields
						if ( "$_" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

							# Display error message
							print "\nError: $_ IP address is not formatted properly\n";
							exit 1;
					
						} else {
							$RRDATA="$_";
							$VALID="VALID";
							close(STDIN);
						}
					}

					# Confirm $RRDATA is not already being used in $DOMAIN_NAME
					&NSLOOKUP($RRDATA);
					if ( "$USED_NAME" eq "YES" ) {

						# Display error message
						print "\nError: The IP \"$RRDATA\" already exists in DNS, unable to add the PTR record for $ADD_NAME\n";
						exit 1;
					}

				# Add "CNAME" record section
				} else {

					print "Enter Host Name to assign $ADD_NAME to > ";

					# Read in responce
					while (<STDIN>) {

						# Remove EOL character
        					chomp $_;

						# Confirm $_ is not a null
						if ( "$_" eq "" ) {
							next ADD_NAME1;
						} else {
							$ALIAS="$_";
							$VALID="VALID";
							close(STDIN);
						} 
					}

					# Set $RECORD_TYPE to A temporally
					$RECORD_TYPE="A";

					# Confirm $_ is in $DOMAIN_NAME exists in $DOMAIN_NAME
					&NSLOOKUP($ALIAS);
					if ( "$USED_NAME" eq "NO" ) {

						# Display error message
						print "\nError: $ALIAS must exist in $DOMAIN_NAME, Unable to add the CNAME record $ADD_NAME.$DOMAIN_NAME\n";
						exit 1;
					}

					# Set $RECORD_TYPE back to CNAME
					$RECORD_TYPE="CNAME";
				}

				# Set VALID
				$VALID="VALID";

				# Open the file INTERACTIVE_FILE for writing
				open (INTERACTIVE_FILE,">$INTERACTIVE_FILE") or die "Error: Unable to open the file $INTERACTIVE_FILE: $!\n";

				# Build the $INTERACTIVE_FILE file
				if ( "$RECORD_TYPE" eq "A" or "$RECORD_TYPE" eq "PTR" ) {
					print INTERACTIVE_FILE "$ADD_NAME $RRDATA $RECORD_TYPE ADD\n";
				} else {
					print INTERACTIVE_FILE "$ADD_NAME $ALIAS $RECORD_TYPE ADD\n";
				}

				# Close the INTERACTIVE_FILE file handle
				close(INTERACTIVE_FILE);
				
			}
		}
	}
1;
}

# The DELETE function is used to delete either A or CNAME records from DNS
sub DELETE_MENU {

	# Remove as needed $INTERACTIVE_FILE
	( -f $INTERACTIVE_FILE ) and unlink $INTERACTIVE_FILE;

	# Print blank line
	print "\n";

	DELETE_NAME: while ( "$VALID" ne "VALID" ) {

		# Display proper message
		if  ( "$RECORD_TYPE" eq "CNAME" ) {
			print "Enter Alias name for the \"$RECORD_TYPE\" record to be deleted > ";
		} else {
			print "Enter host name for the \"$RECORD_TYPE\" record to be deleted > ";
		}
	
		# Read in responce
		while (<STDIN>) {

			# Remove EOL character
       			chomp $_;

			# Set DEL_NAME to $_ 
			$DEL_NAME="$_";

			# Confirm $_ is not a null
			( "$_" eq "" ) and next DELETE_NAME;

			# Delete A record section
			if ( "$RECORD_TYPE" eq "A" ) {

				# Confirm $_ is being used on $MASTER_DNS_SERVER
				&NSLOOKUP($_);
				if ( "$USED_NAME" eq "NO" ) {

					# Display error message
					print "\nError: The name \"$DEL_NAME\" does not exist, unable to delete the A record for $DEL_NAME\n";
					exit 1;
				}

				# Lookup IP for $DELETE_NAME
				# Set $RRDATA to IP of $DELETE_NAME
				$RRDATA="";
				$ADDRESS_COUNT=0;
				&NSLOOKUP($DEL_NAME);

				# If $MULTI_IP is set to YES, ask which IP to delete
				if ( "$MULTI_IP" eq "YES" ) {

					DEL_STEP1: while ( "$VALID2" ne "VALID" ) {
						print "Enter IP address for $DEL_NAME > ";

						# Read in responce
						while (<STDIN>) {

							# Remove EOL character
        						chomp $_;
	
							# Confirm $_ is not a null
							( "$_" eq "" ) and next DEL_STEP1;

							# Confirm that the IP address has 4 fields
							if ( "$_" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

								# Display error message
								print "\nError: $_ IP address is not formatted properly\n";
								exit 1;
					
							} else {
								$RRDATA="$_";
								$VALID2="VALID";
								close(STDIN);
							}
						}
					}
				}

			# Delete PTR record section
			} elsif ( "$RECORD_TYPE" eq "PTR" ) {

				DEL_STEP1: while ( "$VALID2" ne "VALID" ) {
					print "Enter IP address for $DEL_NAME > ";

					# Read in responce
					while (<STDIN>) {

						# Remove EOL character
        					chomp $_;
	
						# Confirm $_ is not a null
						( "$_" eq "" ) and next DEL_STEP1;

						# Confirm that the IP address has 4 fields
						if ( "$_" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

							# Display error message
							print "\nError: $_ IP address is not formatted properly\n";
							exit 1;
					
						} else {
							$RRDATA="$_";
							$VALID2="VALID";
							close(STDIN);
						}
					}
				}

				# Confirm $RRDATA is being used in $DOMAIN_NAME
				&NSLOOKUP($RRDATA);
				if ( "$USED_NAME" eq "NO" ) {

					# Display error message
					print "\nError: The IP \"$RRDATA\" does not exists, unable to delete the PTR record for $DEL_NAME\n";
					exit 1;
				}

			# Delete CNAME record section
			} elsif ( "$RECORD_TYPE" eq "CNAME" ) {

				# Confirm $DEL_NAME is being used in $DOMAIN_NAME
				&NSLOOKUP_QUERY($DEL_NAME,CNAME);
				if ( "$USED_NAME" eq "NO" ) {

					# Display error message
					print "\nError: The name \"$DEL_NAME\" does not exist, unable to delete the CNAME record\n";
					exit 1;
				}

			# Delete Text record section
			} elsif ( "$RECORD_TYPE" eq "TXT" ) {

				# Confirm $DEL_NAME has a Text record in $DOMAIN_NAME
				&NSLOOKUP_QUERY($DEL_NAME,TXT);
				if ( "$USED_NAME" eq "NO" ) {

					# Display error message
					print "\nError: The name \"$DEL_NAME\" does not have a Text record, unable to delete the TXT record\n";
					exit 1;
				}
			}
			
			# Set VALID
			$VALID="VALID";

			# Confirm RRDATA Based on RECORD_TYPE
			if ( "$RECORD_TYPE" eq "PTR" or "$RECORD_TYPE" eq "A" ) {
				# Confirm RRDATA is to an IP
				if ( "$RRDATA" eq "" or "$RRDATA" !~ m/\d+\.\d+\.\d+\.\d+/ ) {

					# Display error message
					print "\nError: The name \"$DEL_NAME\" does not have a valid IP address\n";
					exit 1;
				}
			} elsif ( "$RECORD_TYPE" eq "TXT" ) {
				# Confirm RRDATA is to a 34 digit number/string
				if ( "$RRDATA" eq "" or "$RRDATA" !~ m/................................../ ) {

					# Display error message
					print "\nError: The name \"$DEL_NAME\" does not have a valid TXT record\n";
					exit 1;
				}
			# CNAME
			} else {
				# Confirm RRDATA is set
				if ( "$RRDATA" eq "" ) {

					# Display error message
					print "\nError: The name \"$RRDATA\" does not have a host name\n";
					exit 1;
				}

			}
			close(STDIN);
		}

		# Open the file INTERACTIVE_FILE for writing
		open (INTERACTIVE_FILE,">$INTERACTIVE_FILE") or die "Error: Unable to open the file $INTERACTIVE_FILE: $!\n";

		# Build the $INTERACTIVE_FILE file
		if ( "$RECORD_TYPE" eq "A" or "$RECORD_TYPE" eq "PTR" or "$RECORD_TYPE" eq "TXT" ) {
			print INTERACTIVE_FILE "$DEL_NAME $RRDATA $RECORD_TYPE DELETE\n";
		# CNAME
		} else {
			print INTERACTIVE_FILE "$DEL_NAME $RRDATA $RECORD_TYPE DELETE\n";
		}

		# Close the INTERACTIVE_FILE file handle
		close(INTERACTIVE_FILE);
	}
1;
}

# The NSLOOKUP function is used to run nslookup
sub NSLOOKUP {

	# Pre Set $USED_NAME to NO, $USED_NAME is used to indicate if a $NAME is used or not
	$USED_NAME="NO";

	# Set $NAM, and $DNS_ZONE
	($NAME)=@_;
	#print "NAME = $NAME\n";

	# Add $DOMAIN_NAME to $NAME if it is not an IP and does not already have a domain name included
	( "$NAME" !~ m/\d+\.\d+\.\d+\.\d+/ and "$NAME" !~ m/$DOMAINS/i ) and $NAME="$NAME.$DOMAIN_NAME";
	
	# Open the nslookup command
	$ERROR_MESSAGE="Error $DATE_TIME: Unable to open the command $NSLOOKUP on $HOST\n";
	open(NSLOOKUP,"$NSLOOKUP $NAME $MASTER_DNS_SERVER 2>/dev/null|") or &ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE") and die;

	# Set USED_NAME to YES or NO based on usage of name
	NSLOOKUP: while (<NSLOOKUP>) {

		# Remove EOL character
		chomp $_;

		# Skip blank and Sever lines
		( "$_" =~ /^$/ or "$_" =~ m/^Server:/ ) and next NSLOOKUP;

		# Look for a line that starts Name:
		if ( "$_" =~ m/^Name:/ or "$_" =~ m/name =/ ) {
			$USED_NAME="YES";
		} elsif ( "$USED_NAME" ne "YES" ) {
			$USED_NAME="NO";
		}

		# Set RRDATA to the IP address 
		if ( "$RECORD_TYPE" eq "A" and "$USED_NAME" eq "YES" and "$_" =~ m/^Address:/ ) {
			chomp($RRDATA=(split/:/,$_)[1]);
			$RRDATA=~s/\s+//g;

			# Increment ADDRESS_COUNT
			$ADDRESS_COUNT++;

			# Set MULTI_IP to YES if $ADDRESS_COUNT is greater than 1
			( $ADDRESS_COUNT > 1 ) and $MULTI_IP="YES";

		# Set RRDATA to the IP address 
		} elsif ( "$RECORD_TYPE" eq "A" and "$USED_NAME" eq "YES" and "$_" =~ m/^Addresses:/ ) {
			chomp($RRDATA=(split/:/,$_)[1]);
			$RRDATA=~s/\s+//g;
			$RRDATA=(split/,/,$RRDATA)[0];
			$MULTI_IP="YES";
			last NSLOOKUP;

		# Set RRDATA to the IP address 
		} elsif ( "$RECORD_TYPE" eq "PTR" and "$USED_NAME" eq "YES" ) {

			if ( "$_" =~ m/name =/ ) {
				$RRDATA="$NAME";
				last NSLOOKUP;

			}

		# Set RRDATA to the FQN name that the alias points to
		} elsif ( "$RECORD_TYPE" eq "CNAME" and "$USED_NAME" eq "YES" and "$_" =~ m/^Name:/ ) {
			chomp($RRDATA=(split/:/,$_)[1]);
			$RRDATA=~s/\s+//g;
			last NSLOOKUP;
		}
	}

	close (NSLOOKUP);
1;
}

# The NSLOOKUP_QUERY function is used to run nslookup
sub NSLOOKUP_QUERY {

	# Pre Set $USED_NAME to NO, $USED_NAME is used to indicate if a $NAME is used or not
	$USED_NAME="NO";

	# Pre Set $NAME and $QUERY to a null
	$NAME="";
	$QUERY="";

	# Set $NAM to the first argument
	($NAME)=$_[0];

	# Set $QUERY to the second argument
	$QUERY=$_[1];

	# Add $DOMAIN_NAME to $NAME if it does not already have a domain name included
	( "$NAME" !~ m/$DOMAINS/i ) and $NAME="$NAME.$DOMAIN_NAME";
	#print "NAME = $NAME\n";

	# Open the nslookup command
	$ERROR_MESSAGE="Error $DATE_TIME: Unable to open the command $NSLOOKUP on $HOST\n";
	open(NSLOOKUP2,"$NSLOOKUP -query=$QUERY $NAME $MASTER_DNS_SERVER 2>/dev/null|") or &ERROR_EMAIL("$ERROR_MESSAGE") and &LOG("$ERROR_MESSAGE") and die;

	# Set USED_NAME to YES or NO based on usage of name
	NSLOOKUP: while (<NSLOOKUP2>) {

		# Remove EOL character
		chomp $_;

		# Skip blank and Sever lines
		( "$_" =~ /^$/ or "$_" =~ m/^Server:/ ) and next NSLOOKUP;

		# Look for a lines that include the key words "canonical name ="
		if ( "$_" =~ m/canonical name =/ and "$QUERY" eq "CNAME" ) {

			$USED_NAME="YES";

			chomp($RRDATA=(split/\s/,$_)[4]);
			$RRDATA=~s/\.com\./\.com/;
			$RRDATA=~s/\.local\./\.local/;
			last NSLOOKUP;
		} elsif ( "$_" =~ m/text =/ and "$QUERY" eq "TXT" ) {

			$USED_NAME="YES";

			chomp($RRDATA=(split/\s/,$_)[3]);
			$RRDATA=~s/\"//g;
			last NSLOOKUP;
		}
	}
	close (NSLOOKUP2);
1;
}
