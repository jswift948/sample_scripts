#!/bin/bash
# oractl_11g
# Purpose: The purpose of this script is to provide a menu driven tool to
# manage the Oracle 10g RAC environment. It can be used to start/stop/status and list 
# any Database, Listener, Service, Enterprise Manager, and Cluster Ready Services.
# It can also be used to add and remove resources from CRS.

# Written By: Jon Swift 03/07
# Updated 06/08, replaced all use of "rsh" with "ssh"
# Updated 03/12, Updated to support Oracle 11G RAC
# Updated 01/16, Corrected bug generated by system updates to the remote CRS check section

# Dependency: The format of the both "service" names and "instance" names is very important.
# The "service name needs to SVC_Database name. And the instance name must be database#, 
# where # is matches the last digit in the host name. If either of these names use a different
# format this script will FAIL.


PROG=`basename $0`
HOST=`uname -n`
DONE=NOT_DONE
WORK_DIR=/tmp/${PROG}
GRID_HOME=/export/apps/grid/grid_11.2
PATH=${PATH}:${GRID_HOME}/bin
CLUSTER=`echo ${HOST} | sed 's/\(.*\)\([1-9]$\)/\1/'`
TTY=`tty | sed 's{/dev/pts/{{'`
LOCK_FILE=/tmp/${PROG}_lock.${TTY}
trap 'rm -f ${LOCK_FILE}; exit 1' 1 2 3 6 15
SETCOLOR_GREEN="echo -en \\033[1;32m"
SETCOLOR_RED="echo -en \\033[1;31m"
SETCOLOR_NORMAL="echo -en \\033[0;39m"
IFS_ORIG=${IFS}
stty erase  2>/dev/null

# Clear Screen
clear

# Make sure this scipt is run as root
if [ `whoami` != root ];then

	echo ""
	echo " Error: ${PROG} can only be run as root"
	echo ""
	exit
fi

# Confirm that GRID_HOME  exists
if [ "$1" != -f ];then
if [ ! -d ${GRID_HOME} ];then

	echo ""
	echo " Error: The required directory \"${GRID_HOME}\" does not exist"
	exit
fi
fi

# Confirm this script is run on a 11gRAC system
if [ "$1" != -f ];then
RDBMS_VERSION=`echo exit | sqlplus 2>/dev/null | grep Release | awk '{print $3}'`
if [ `echo ${RDBMS_VERSION} | grep -c '^11\.2\.0'` -eq 0 ];then

	echo ""
	echo " Error: ${PROG} requires that Oracle RDBMS version 11.2.0.X be loaded"
	exit
fi
fi

# Set CHECK_CRS to NO if the 1st agr is set to -a
if [ "$1" = -a -o ${PROG} = asmctl ];then

	CHECK_CRS=NO
	PROG=asmctl
else
	CHECK_CRS=YES
fi

# This function WATCH_RPCINFO, is used to monitor and then kill the 
# rpcinfo process if it runs for longer then 10 seconds
###########################################################################
WATCH_RPCINFO () 
{
	# set -x

	while [ ${RUN} = YES ]
	do

		# Check to make sure the LOCK_FILE is there, if it is the main program is still 
		# running. Which means this function should keep running in background
 		if [ -f ${LOCK_FILE} ];then

         		# Set RUP_PID_1 to the first PID of the "rpcinfo -p ${NODE_NAME}" 
			# for this window
         		RUP_PID_1=`ps -aef | grep "pts/${TTY}" | grep "rpcinfo -p ${NODE_NAME}" | 
				grep -v grep | awk '{print $2}' | awk '{print $1}'`
	
         		# wait 5 seconds
         		sleep 5
	
         		# Check to make sure RUP_PID_1 is set
         		[ "${RUP_PID_1}" = "" ] && continue
   		fi
	
		# Set RUP_PID_2 to the first PID of the "rpcinfo -p ${NODE_NAME}" for this window
        	RUP_PID_2=`ps -aef | grep "pts/${TTY}" | grep "rpcinfo -p ${NODE_NAME}" | 
			grep -v grep | awk '{print $2}' | awk '{print $1}'`
	
        	# if after ten seconds RUP_PID_1 is equal to RUP_PID_2 double check it
        	if [ "${RUP_PID_1}" = "${RUP_PID_2}" -a "${RUP_PID_1}" != "" ];then
	
			# wait 5 seconds
			sleep 5
			# Set RUP_PID_2 to the first PID of the 
			# "rpcinfo -p ${NODE_NAME}" for this window
			RUP_PID_2=`ps -aef | grep "pts/${TTY}" | grep "rpcinfo -p ${NODE_NAME}" | 
				grep -v grep | awk '{print $2}' | awk '{print $1}'`
	
	
			# Double check if RUP_PID_1 still equal to RUP_PID_2
			# if RUP_PID_1 still equal to RUP_PID_2 kill all the 
			# "rpcinfo -p ${NODE_NAME}" process for this window"
			if [ "${RUP_PID_1}" = "${RUP_PID_2}" ];then
	
				# Set RUP_PIDS to all th PIDS for 
				# "rpcinfo -p ${NODE_NAME}" for this window
				RUP_PIDS=`ps -aef | grep "pts/${TTY}" | 
					grep "rpcinfo -p ${NODE_NAME}" | grep -v grep | 
					awk '{print $2}'`

				# kill all the "rpcinfo -p ${NODE_NAME}" process
				echo "Killing ${RUP_PIDS}"
				kill -9 ${RUP_PIDS} 2> /dev/null
	
			fi
	
		else
			# Time for this function to end
			RUN=NO
		fi
	done
}

# The function REMOTE_UP is used to set the variable UP_DOWN. If UP_DOWN
# is set to DOWN it means the $NODE_NAME is Down
###########################################################################
REMOTE_UP () 
{
	# set -x

	rm -f ${LOCK_FILE}

	# Set NODE_NAME to the supplied argument
	NODE_NAME=$1

	# Confirm node is up first with ping
	if [ `ping -f -i .3 -w 1 ${NODE_NAME} | grep -c '100% packet loss'` -eq 1 ];then

		UP_DOWN=DOWN
	else
		touch ${LOCK_FILE}
		chmod 666 ${LOCK_FILE}
		export RUN=YES
		WATCH_RPCINFO &

		# Set RUP_DATA, to the output from the command "rup $NODE_NAME
		UP_DOWN=""
		RUP_DATA=`rpcinfo -p ${NODE_NAME} 2>&1`
	
		if [ `echo ${RUP_DATA} | egrep -c 'ypbind'` -ge 1 ];then
			UP_DOWN=UP	

		else
			UP_DOWN=DOWN	

			# Set TOTAL_REMOTE_NODES_DOWN to the number of remote systems that are down
			if [ "${TOTAL_REMOTE_NODES_DOWN}" = "" ];then
				TOTAL_REMOTE_NODES_DOWN=1
			else
				let TOTAL_REMOTE_NODES_DOWN=${TOTAL_REMOTE_NODES_DOWN}+1
			fi
		fi
	fi
	rm -f ${LOCK_FILE}
	export RUN=NO

	# Set LAST_SYSTEM_UP to YES if this local system is the last system up
	if [ "${TOTAL_REMOTE_NODES_DOWN}" = "${TOTAL_REMOTE_NODES}" -a "${TOTAL_REMOTE_NODES}" != "" ];then 
		LAST_SYSTEM_UP=YES
	else
		LAST_SYSTEM_UP=NO
	fi
}

# The function ASK is used to confirm Operation
###########################################################################
ASK () 
{
	# set -x
	ORIG_NODE_NAME=""

	# Redefine NODE_NAME as needed
	[ "${NODE_NAME}" = "ALL" ] && NODE_NAME="All Nodes"

	OBJECT=""
	if [ "$1" = IMPORT ];then
		FUNCTION=Import
		ORIG_NODE_NAME=${NODE_NAME}
		NODE_NAME="${HOST} to ${NODE_NAME}"
	elif [ "$1" != "" -a "$1" != IMPORT ];then  
		OBJECT=" $1"
	fi

	# Comfirm operation
	ANSWER=""
	echo ""
	until [ -n "${ANSWER}" ]
	do
		echo -n " ${FUNCTION} ${RESOURCE}${OBJECT} on ${NODE_NAME} Y/N > "
		read ANSWER

		case ${ANSWER} in

        		"") # Do Nothing
			;;

        		N|n|NO|no|No)  # No
			ANSWER=NO
        		;;
	
        		Y|y|YES|yes|Yes) # Yes
			ANSWER=YES
        		;;
	
        		q|Q) # Exit Now
			ANSWER=NO
			exit
        		;;
	
        		*) # Invalid Answer
        		echo ""
        		echo " Invalid selection ${ANSWER}"
        		echo ""
        		ANSWER=""
        		sleep 1
			;;
		esac
	done
	[ "${ORIG_NODE_NAME}" != "" ] && NODE_NAME=${ORIG_NODE_NAME}
	[ "${NODE_NAME}" = "All Nodes" ] && NODE_NAME=""
}

# The function START_CRS is used to start the CRS processes
###########################################################################
START_CRS () 
{
	# set -x

	# Set NODE_NAME to the supplied argument
	NODE_NAME=$1

	# Determine if the CRS processes should be started
	CRS_ANSWER=""
	until [ -n "${CRS_ANSWER}" ]
	do
		echo -n " Start CRS on ${NODE_NAME} Y/N > "
		read CRS_ANSWER

		case ${CRS_ANSWER} in

        		""|N|n|NO|no|No) 

				# If $HOST = $NODE_NAME	 display error and exit
				if [ ${HOST} = ${NODE_NAME} ];then

					echo ""
					echo " Error: ${PROG} requires CRS be running on local node."
					echo " Either start CRS on ${HOST} or run it from a different node."
					echo ""
					exit 0
					echo
				fi
        		;;
	
        		Y|y|YES|yes|Yes)
			echo ""
			echo " ${PROG}: Using the following commands"

			# Determine if crsctl start should be run locally or not
			if [ "${NODE_NAME}" = ${HOST} ];then

				# Determine if CRS is already running, and stop it if it is running
				if [ `ps -aef | grep -w crs | grep -v grep | wc -l` -gt 2 ];then

					# Stop CRS
					echo " crsctl stop crs"
					echo ""
					crsctl stop crs

					# Wait 30 seconds for CRS to completly stop
					echo ""
					echo " Waiting 30 seconds for CRS to stop"
					SLEEP_COUNT=1
					while  [ ${SLEEP_COUNT} -lt 5 ]
					do
						echo -n '.'
						sleep 5
						let SLEEP_COUNT=${SLEEP_COUNT}+1
					done
					echo ""
					echo " ${PROG}: Using the following commands"
				fi

				# Start CRS
				echo " crsctl start crs"
				echo ""
				crsctl start crs
			else

				# Confirm ${NODE_NAME} is up
				REMOTE_UP ${NODE_NAME}
				if [ ${UP_DOWN} = DOWN ];then
					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS"
					sleep 1
				else
					echo " ssh ic-${NODE_NAME} crsctl start crs"
					echo ""
					ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl start crs"
				fi
			fi

			echo ""
			echo " Wait 30-60 seconds before running ${PROG} again"
			echo ""
			exit
        		;;

        		q|Q) # Exit Now
			exit 0
        		;;
	
        		*)
        		echo ""
        		echo " Invalid selection ${ANSWER}"
        		echo ""
        		CRS_ANSWER=""
        		sleep 1
			;;
		esac
	done
}

# The function GET_REMOTE_HOST_NAMES, adds the Remote Host Names to the Array HOST_NAMES
###########################################################################
GET_REMOTE_HOST_NAMES ()
{
	# set -x

	# Clear all old entrys in REMOTE_HOST_NAMES
	unset REMOTE_HOST_NAMES[*]

	# Add Remote Host Names to the Array REMOTE_HOST_NAMES
	###########################################################################
	LOOP=1
	for REMOTE_HOST_NAME in `grep -P "\s${CLUSTER}\d\s" /etc/hosts | grep -v '^#' |
		awk '{print $2}' | grep -v ${HOST} | sort`
	do
		# Confirm REMOTE_HOST_NAME is set properly
		if [ "${REMOTE_HOST_NAME}" = "" ];then

			echo ""
			echo " Error: Problem with getting Remote Host Names from /etc/hosts file"
			echo " Unable to continue"
			exit 
		fi
	
		# Build the array REMOTE_HOST_NAMES, Add only the REMOTE_HOST_NAME
		REMOTE_HOST_NAMES[${LOOP}]=${REMOTE_HOST_NAME}

		# Set TOTAL_REMOTE_NODES to $LOOP
		TOTAL_REMOTE_NODES=${LOOP}

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	# Confirm LOOP is not still set to 1, if it is, no Host names were set
	if [ ${LOOP} -ne 4 ];then

		echo ""
		echo " Error: Problem with getting Remote Host Names from /etc/hosts file"
		echo " Suspect /etc/hosts file on ${HOST} not setup properly"
		echo " Unable to continue"
		exit 
	fi
}

# The function CRS_CHECK, check the current status of CRS
###########################################################################
CRS_CHECK () 
{
	echo ""
	echo ""
	echo ""
	echo " Checking status of \"CRS\" on ${HOST}"

	# Confirm all CRS is working properly on local node
	if [ `crsctl check crs 2>&1 | grep -c 'online'` -ne 4 ];then

		clear
		echo ""
		echo " Error: Problem with the \"CRS\" on ${HOST}"
		echo ""
		START_CRS ${HOST}
	fi

	# Set Remote host Names
	GET_REMOTE_HOST_NAMES

	# Confirm that CRS is working properly on remote nodes
	LOOP=1
	while [ "${REMOTE_HOST_NAMES[${LOOP}]}" ]
	do

		# Set NODE_NAME
		NODE_NAME=${REMOTE_HOST_NAMES[${LOOP}]}

		# Confirm ${NODE_NAME} is up
		REMOTE_UP ${NODE_NAME}
		if [ ${UP_DOWN} = DOWN ];then

			echo ""
			echo " Note: Remote node ${NODE_NAME} is down"
			echo
			sleep 1
		else
			echo " Checking status of \"CRS\" on ${NODE_NAME}"

			# Confirm all CRS process are working properly
			if [ `ssh -q -n ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl check crs" 2>&1 |
					grep -c 'online'` -ne 4 ];then
				clear
				echo ""
				echo " Error: Problem with the \"CRS\" on ${NODE_NAME}"
				echo ""
				START_CRS ${NODE_NAME}
			fi
		fi

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	clear
}

# The function GET_INSTANCE_NAMES, adds the DB Instance Names to the Array INSTANCE_NAMES
###########################################################################
GET_INSTANCE_NAMES ()
{
	# set -x

	# Clear all old entrys in INSTANCE_NAMES
	unset INSTANCE_NAMES[*]

	# Set SORT based on $FUNCTION
	if [ "${1}" = Reverse ];then
		SORT="sort -r"
	else
		SORT="sort"
	fi

	# Add Instanse Names to the Array INSTANCE_NAMES
	###########################################################################
	LOOP=1
	for INSTANCE_NAME in `crsctl status resource -f | egrep '^USR_ORA_INST_NAME@' | 
		awk -F= '{print $2}' | ${SORT} | tr '[A-Z]' '[a-z]'`
	do
		# Confirm INSTANCE_NAME is set properly
		if [ "${INSTANCE_NAME}" = "" ];then
			echo ""
			echo " Error: Problem with getting Instance Names using crsctl status resource"
			echo " Suspect CRS has been shut down on ${HOST}"
			echo " Unable to continue"
			exit 
		fi

		# Set INST_DB to the database name for $INSTANCE_NAME
		# Remove inst number, trailing number
		INST_DB=`echo ${INSTANCE_NAME} | sed 's/\(.*\)[1-4]/\1/'`
	
		# Set HOST_NAME and STATE for ${INSTANCE_NAME}
		INST_INFO=`srvctl status instance -d ${INST_DB} -i ${INSTANCE_NAME}`
		STATE=`echo ${INST_INFO} | awk '{print $4}'`
		REAL_HOST_NAME=`echo ${INST_INFO} | awk '{print $NF}'`

		# Set ASSIGNED_HOST_NAME to the primary host name for $INSTANCE_NAME
		ASSIGNED_HOST_NAME="${CLUSTER}`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-4]\)/\2/'`" 

		# Confirm REAL_HOST_NAME is set
		[ "${REAL_HOST_NAME}" = "" ] && REAL_HOST_NAME=${ASSIGNED_HOST_NAME}

		# Skip this entry if $HOST_NAME does not match $NODE_NAME
		[ "${REAL_HOST_NAME}" != "${NODE_NAME}" -a "${NODE_NAME}" != ALL ] && continue

		# Build the array INSTANCE_NAMES, Add INSTANCE_NAME, STATE and HOST_NAME
		INSTANCE_NAMES[${LOOP}]="${INSTANCE_NAME} ${STATE} ${REAL_HOST_NAME} ${ASSIGNED_HOST_NAME}"

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	
	# Confirm LOOP is not still set to 1, if it is, no Instance names were set
	if [ ${LOOP} -eq 1 ];then

		echo ""
		echo " Error: Problem with getting Instance Names using crsctl status resource part 2"
		echo " Suspect CRS has been shut down on ${HOST}"
		echo " Unable to continue"
		exit 
	fi

	# Reset HOST_NAME to a null
	HOST_NAME=""

}

# The function GET_LISTENER_NAMES, adds the Listener Names to the Array LISTENER_NAMES
###########################################################################
GET_LISTENER_NAMES ()
{
	# set -x

	# Clear all old entrys in LISTENER_NAMES
	unset LISTENER_NAMES[*]

	# Add Listener Names to the Array LISTENER_NAMES
	###########################################################################
	LOOP=1
	for LISTENER_NAME in `crsctl status resource -f | grep NAME | egrep 'LISTENER_SCAN' | 
		awk -F= '{print $2}' | sort`
	do
		# Confirm LISTENER_NAME is set properly
		if [ "${LISTENER_NAME}" = "" ];then
			echo ""
			echo " Error: Problem with getting Listener Names using crsctl status resource"
			echo " Suspect CRS has been shut down on ${HOST}"
			echo " Unable to continue"
			exit 
		fi
	
		# Set HOST_NAME and STATE for ${LISTENER_NAME}
		HOST_NAME_STATE=`crsctl status resource ${LISTENER_NAME} | 
			grep STATE | awk -F= '{print $2}'| awk '{print $1, $3}' | sort`
		STATE=`echo ${HOST_NAME_STATE} | awk '{print $1}'`
		REAL_HOST_NAME=`echo ${HOST_NAME_STATE} | awk '{print $2}'`

		# Set ASSIGNED_HOST_NAME to the primary host name for $LISTENER_NAME
		ASSIGNED_HOST_NAME="${CLUSTER}`echo ${LISTENER_NAME} | awk -F. '{print $2}' |
			sed 's/\(.\)/ \1/g' | awk '{print $NF}'`"

		# Set LISTENER_TYPE to the type of listener
		LISTENER_TYPE=`crsctl status resource ${LISTENER_NAME} | grep TYPE | awk -F= '{print $2}'`

		# Confirm LISTENER_TYPE is set properly
		if [ "${LISTENER_TYPE}" = application ];then

			# Strip off ora.hostname and lsnr
			# ora.ractst04.LISTENER_RACTST01.lsnr
			LISTENER_NAME=`echo ${LISTENER_NAME} | awk -F. '{print $3}'`

			echo ""
			echo " Error: Problem with getting Listener Type using crsctl status resource"
			echo " Suspect CRS has been shut down on ${HOST}"
			echo " Unable to continue"
			exit 

		elif [ "${LISTENER_TYPE}" = ora.scan_listener.type ];then

			# Strip off ora and lsnr
			# ora.LISTENER_SCAN1.lsnr
			LISTENER_NAME=`echo ${LISTENER_NAME} | awk -F. '{print $2}'`

		else
			echo ""
			echo " Error: Problem with getting Listener Type using crsctl status resource"
			echo " Suspect CRS has been shut down on ${HOST}"
			echo " Unable to continue"
			exit 
		fi

		# Confirm HOST_NAME is set
		[ "${REAL_HOST_NAME}" = "" ] && REAL_HOST_NAME=${ASSIGNED_HOST_NAME}

		# Skip this entry if $HOST_NAME does not match $NODE_NAME
		[ "${REAL_HOST_NAME}" != "${NODE_NAME}" -a "${NODE_NAME}" != ALL ] && continue

		# Build the array LISTENER_NAMES, Add LISTENER_NAME, STATE and HOST_NAME
		LISTENER_NAMES[${LOOP}]="${LISTENER_NAME} ${STATE} ${REAL_HOST_NAME} ${ASSIGNED_HOST_NAME}"
	
		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	
	# Confirm LOOP is not still set to 1, if it is, no Listener names were set
	if [ ${LOOP} -eq 1 ];then

		echo ""
		echo " Error: Problem with getting Listener Names using crsctl status resource"
		echo " Suspect CRS has been shut down on ${HOST}"
		echo " Unable to continue"
		exit 
	fi

	# Reset HOST_NAME to a null
	HOST_NAME=""
}

# The function GET_VIP_NAMES, adds all the Host Names to the Array VIP_NAMES
###########################################################################
GET_VIP_NAMES ()
{
	# set -x

	# Clear all old entrys in VIP_NAMES
	unset VIP_NAMES[*]

	# Set SORT based on $FUNCTION
	if [ "${FUNCTION}" = Status ];then
		SORT="sort -u"
	else
		SORT="sort"
	fi

	# Add Instanse Names to the Array INSTANCE_NAMES
	###########################################################################
	LOOP=1
	for VIP_NAME in `crsctl status resource | grep NAME | egrep '.+\.vip' | egrep -v scan |
		awk -F= '{print $2}' | ${SORT}`
	do
		# Confirm VIP_NAME is set properly
		if [ "${VIP_NAME}" = "" ];then

			echo ""
			echo " Error: Problem with getting VIP Names using crsctl status resource"
			echo " Suspect CRS has been shut down on ${HOST}"
			echo " Unable to continue"
			exit 
		fi
	
		# Set HOST_NAME_STATE and STATE based on ${VIP_NAME}
		HOST_NAME_STATE=`crsctl status resource ${VIP_NAME} | 
			grep STATE | awk -F= '{print $2}'| awk '{print $1, $3}' | sort`
		STATE=`echo ${HOST_NAME_STATE} | awk '{print $1}'`

		# Set REAL_HOST_NAME to the host name supporting the VIP
		REAL_HOST_NAME=`echo ${HOST_NAME_STATE} | awk '{print $2}'`

		# Set ASSIGNED_HOST_NAME to the primary host name for $VIP_NAME
		ASSIGNED_HOST_NAME=`echo ${VIP_NAME} | awk -F. '{print $2}'`

		# Confirm HOST_NAME is set
		[ "${REAL_HOST_NAME}" = "" ] && REAL_HOST_NAME=${ASSIGNED_HOST_NAME}

		# Skip this entry if $REAL_HOST_NAME does not match $NODE_NAME and
		# $ASSIGNED_HOST_NAME does not match $NODE_NAME and $NODE_NAME does not match ALL
		[ "${ASSIGNED_HOST_NAME}" != "${NODE_NAME}" -a "${REAL_HOST_NAME}" != "${NODE_NAME}" -a "${NODE_NAME}" != ALL ] && continue

		# Build the array VIP_NAMES, Add VIP_NAME, STATE and HOST_NAME
		VIP_NAMES[${LOOP}]="${VIP_NAME} ${STATE} ${REAL_HOST_NAME} ${ASSIGNED_HOST_NAME}"

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	
	# Confirm LOOP is not still set to 1, if it is, no VIP names were set
	if [ ${LOOP} -eq 1 ];then

		echo ""
		echo " Error: Problem with getting VIP Names using crsctl status resource"
		echo " Suspect CRS has been shut down on ${HOST}"
		echo " Unable to continue"
		exit 
	fi

	# Reset HOST_NAME to a null
	HOST_NAME=""

}

# The function GET_DB_NAMES, adds the Database Names to the Array DB_NAMES
###########################################################################
GET_DB_NAMES ()
{
	# set -x

	# Clear all old entrys in DB_NAMES
	unset DB_NAMES[*]

	# Add Database Names to the Array DB_NAMES
	###########################################################################
	LOOP=1
	for DB_NAME in `crsctl status resource | grep NAME | egrep '.+\.db$' | 
		awk -F= '{print $2}' | sort`
	do
		# Confirm DB_NAME is set properly
		if [ "${DB_NAME}" = "" ];then

			echo ""
			echo "Error: Problem with getting Database Names using crsctl status resource"
			echo "Suspect CRS has been shut down on ${HOST}"
			echo "Unable to continue"
			exit 
		fi

		# Strip off ora and db
		# ora.srp.db
		DB_NAME=`echo ${DB_NAME} | awk -F. '{print $2}'`

		# Build the array DB_NAME, Add DB_NAME, STATE and REAL_HOST_NAME
		DB_NAMES[${LOOP}]="${DB_NAME}"

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	# Confirm LOOP is not still set to 1, if it is, no Database names were set
	if [ ${LOOP} -eq 1 ];then

		echo ""
		echo "Error: Problem with getting Database Names using crsctl status resource"
		echo "Suspect CRS has been shut down on ${HOST}"
		echo "Unable to continue"
		exit 
	fi

	# Reset HOST_NAME to a null
	HOST_NAME=""
}

# Function to Select/Set Instance Name
###########################################################################
SET_INSTANCE_NAME () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***************************${BANNER}"
	echo " * Select ${RESOURCE} Name to ${FUNCTION} *"
	echo " ***************************${BANNER}"
	echo ""
	while [ "${INSTANCE_NAMES[${LOOP}]}" ]
	do

		INSTANCE_NAME=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $1}'`
		echo " ${LOOP} > ${INSTANCE_NAME}" | awk '{printf"%4-s%2-s%1-s\n", " "$1,$2,$3}'

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	INSTANCE_NAME=""
	let LOOP=${LOOP}-1

	# Confirm the selection
	until [ -n "${INSTANCE_NAME}" ]
	do
		echo -n " Enter selection > "
		read INSTANCE_NAME

		if [ "${INSTANCE_NAME}" = "" ];then
			true

		# Confirm INSTANCE_NAME is not quit
		elif [ `echo ${INSTANCE_NAME} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0
		
		# Confirm INSTANCE_NAME is a Number
		elif [ `echo ${INSTANCE_NAME} | egrep -c '[^0-9]'` -eq 1 ];then
        		echo " Invalid selection, ${INSTANCE_NAME}"
			INSTANCE_NAME=""
        		sleep 1
			echo ""

		# Confirm INSTANCE_NAME is not greater than ${LOOP} and not equal to 0
		elif [ ${INSTANCE_NAME} -gt ${LOOP} -o ${INSTANCE_NAME} -eq 0 ];then
        		echo " Invalid selection, ${INSTANCE_NAME}"
			INSTANCE_NAME=""
        		sleep 1
			echo ""
		else
        		VALID=TRUE
			INSTANCE_NAME=`echo ${INSTANCE_NAMES[${INSTANCE_NAME}]} | awk '{print $1}'`

			# Confirm INSTANCE_NAME is set properly
			if [ "${INSTANCE_NAME}" = "" ];then
				echo ""
				echo " Error: Problem setting the Instance Name"
				exit 1
			fi
		fi
	done

	# Reset NODE_NAME as needed
	if [ "${NODE_NAME}" = ALL ];then

		LOOP=1
		while [ "${INSTANCE_NAMES[${LOOP}]}" ]
		do

			if [ ${INSTANCE_NAME} = `echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $1}'` ];then
				NODE_NAME=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $4}'`
				break
			fi

			# Increment LOOP
			let LOOP=${LOOP}+1
		done
	fi
}

# Function to Set Listener LISTENER_REAL_HOST_NAME
###########################################################################
SET_LISTENER_REAL_HOST_NAME ()
{
	# set -x

	LOOP=1
	LISTENER_REAL_HOST_NAME=""
	while [ "${LISTENER_NAMES[${LOOP}]}" ]
	do
		if [ "${LISTENER_NAME}" = `echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $1}'` ];then
			LISTENER_REAL_HOST_NAME=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $3}'`
			break
		fi

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	# Confirm LISTENER_REAL_HOST_NAME is not a null
	if [ "${LISTENER_REAL_HOST_NAME}" = "" ];then
		echo ""
		echo " Error: Problem setting LISTENER_REAL_HOST_NAME"
		exit 1
	fi
}

# Function to Select/Set Listener Name
###########################################################################
SET_LISTENER_NAME () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***************************${BANNER}"
	echo " * Select ${RESOURCE} Name to ${FUNCTION} *"
	echo " ***************************${BANNER}"
	echo ""
	while [ "${LISTENER_NAMES[${LOOP}]}" ]
	do
		LISTENER_NAME=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $1}'`
		echo " ${LOOP} > ${LISTENER_NAME}" | awk '{printf"%4-s%2-s%1-s\n", " "$1,$2,$3}'

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	LISTENER_NAME=""
	let LOOP=${LOOP}-1

	# Confirm the selection
	until [ -n "${LISTENER_NAME}" ]
	do
		echo -n " Enter selection > "
		read LISTENER_NAME

		# Confirm LISTENER_NAME is not a null
		if [ "${LISTENER_NAME}" = "" ];then
        		true

		# Confirm LISTENER_NAME is not quit
		elif [ `echo ${LISTENER_NAME} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0

		
		# Confirm LISTENER_NAME is a Number
		elif [ `echo ${LISTENER_NAME} | egrep -c '[^0-9]'` -eq 1 ];then
        		echo " Invalid selection, ${LISTENER_NAME}"
			LISTENER_NAME=""
        		sleep 1
			echo ""

		# Confirm LISTENER_NAME is not greater than $LOOP and not equal to 0
		elif [ ${LISTENER_NAME} -gt ${LOOP} -o ${LISTENER_NAME} -eq 0 ];then

        		echo " Invalid selection, ${LISTENER_NAME}"
			LISTENER_NAME=""
        		sleep 1
			echo ""
		else

			# If $LOCAL_REMOTE = ALL, Reset LOCAL_REMOTE to either LOCAL
			# or REMOTE and set $NODE_NAME
			if [ ${LOCAL_REMOTE} = ALL ];then

				# Set NODE_NAME
				NODE_NAME=`echo ${LISTENER_NAMES[${LISTENER_NAME}]} | awk '{print $4}'`

				# ReSet LOCAL_REMOTE
				if [ "${NODE_NAME}" = ${HOST} ];then
					LOCAL_REMOTE=LOCAL
				else
					LOCAL_REMOTE=REMOTE
				fi
			fi

        		VALID=TRUE
			LISTENER_NAME=`echo ${LISTENER_NAMES[${LISTENER_NAME}]} | awk '{print $1}'`

			# Confirm LISTENER_NAME is set properly
			if [ "${LISTENER_NAME}" = "" ];then
				echo ""
				echo " Error: Problem setting the Listener Name"
				exit 1
			fi
		fi
	done
}

# Function to Select/Set Service Name
###########################################################################
SET_SERVICE_NAME () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***************************${BANNER}"
	echo " * Select ${RESOURCE} Name to ${FUNCTION} *"
	echo " ***************************${BANNER}"
	echo ""
	while [ "${SERVICE_NAMES[${LOOP}]}" ]
	do
		SERVICE_NAME=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $1}'`
		echo " ${LOOP} > ${SERVICE_NAME}" | awk '{printf"%3-s%2-s%1-s\n", " "$1,$2,$3}'

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	SERVICE_NAME=""
	let LOOP=${LOOP}-1

	# Confirm the selection
	until [ -n "${SERVICE_NAME}" ]
	do
		echo -n " Enter selection > "
		read SERVICE_NAME

		# Confirm SERVICE_NAME is not a null
		if [ "${SERVICE_NAME}" = "" ];then
			true

		# Confirm SERVICE_NAME is not quit
		elif [ `echo ${SERVICE_NAME} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0
		
		# Confirm SERVICE_NAME is a Number
		elif [ `echo ${SERVICE_NAME} | egrep -c '[^0-9]'` -eq 1 ];then

        		echo " Invalid selection, ${SERVICE_NAME}"
			SERVICE_NAME=""
        		sleep 1
			echo ""

		# Confirm SERVICE_NAME is not greater than $LOOP and not equal to 0
		elif [ ${SERVICE_NAME} -gt ${LOOP} -o ${SERVICE_NAME} -eq 0 ];then

        		echo " Invalid selection, ${SERVICE_NAME}"
			SERVICE_NAME=""
        		sleep 1
			echo ""
		else
        		VALID=TRUE
			SERVICE_NAME=`echo ${SERVICE_NAMES[${SERVICE_NAME}]} | awk '{print $1}'`

			# Confirm SERVICE_NAME is set properly
			if [ "${SERVICE_NAME}" = "" ];then

				echo ""
				echo " Error: Problem setting the Service Name"
				exit 1
			fi

			# Set DB_NAME based on $SERVICE_NAME
			DB_NAME=`echo ${SERVICE_NAME} | awk -F. '{print $1}' | 
				awk -F_ '{print $2}' | tr '[A-Z]' '[a-z]'`
		fi
	done

	# Reset NODE_NAME as needed
	if [ "${NODE_NAME}" = ALL ];then

		LOOP=1
		while [ "${SERVICE_NAMES[${LOOP}]}" ]
		do

			if [ ${SERVICE_NAME} = `echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $1}'` ];then
				NODE_NAME=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $4}'`
				break
			fi

			# Increment LOOP
			let LOOP=${LOOP}+1
		done
	fi
}

# Function to Select/Set VIP resource Name
###########################################################################
SET_VIP_NAME () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***********************************************"
	echo " * Select VIP Name to ${FUNCTION} to deafult node *"
	echo " ***********************************************"
	echo ""
	while [ "${VIP_NAMES[${LOOP}]}" ]
	do

		VIP_NAME=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $1}'`
		echo " ${LOOP} > ${VIP_NAME}" | awk '{printf"%3-s%2-s%1-s\n", " "$1,$2,$3}'

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	VIP_NAME=""
	let LOOP=${LOOP}-1

	# Confirm the selection
	until [ -n "${VIP_NAME}" ]
	do
		echo -n " Enter selection > "
		read VIP_NAME

		if [ "${VIP_NAME}" = "" ];then
			true

		# Confirm VIP_NAME is not quit
		elif [ `echo ${VIP_NAME} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0

		# Confirm VIP_NAME is number
		elif [ `echo ${VIP_NAME} | grep -c "[^0-9]"` -eq 1 ] ;then

       			echo " Invalid selection, ${INSTANCE_NAME}"
			VIP_NAME=""
       			sleep 1
			echo ""

		# Confirm VIP_NAME is not greater than $LOOP and not equal to 0
		elif [ ${VIP_NAME} -gt ${LOOP} -o ${VIP_NAME} -eq 0 ] ;then

       			echo " Invalid selection, ${INSTANCE_NAME}"
			VIP_NAME=""
       			sleep 1
			echo ""
		else
			# Set VIP_NAME
			VIP_NAME=`echo ${VIP_NAMES[${VIP_NAME}]} | awk '{print $1}'`
		fi
	done

	# Reset NODE_NAME as needed
	if [ "${NODE_NAME}" = ALL ];then

		LOOP=1
		while [ "${VIP_NAMES[${LOOP}]}" ]
		do

			if [ "${VIP_NAME}" = "`echo ${VIP_NAMES[${LOOP}]} | awk '{print $1}'`" ];then
				NODE_NAME=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $4}'`
				break
			fi

			# Increment LOOP
			let LOOP=${LOOP}+1
		done
	fi
}

# Function to Select/Set Database Name
###########################################################################
SET_DB_NAME () 
{
	# set -x

	LOOP=1
	echo ""
	echo " *******************************${BANNER}"
	echo " * Select Database Name to ${FUNCTION} *"
	echo " *******************************${BANNER}"
	echo ""
	while [ "${DB_NAMES[${LOOP}]}" ]
	do
		DB_NAME=`echo ${DB_NAMES[${LOOP}]} | awk '{print $1}'`
		echo " ${LOOP} > ${DB_NAME}" | awk '{printf"%4-s%2-s%1-s\n", " "$1,$2,$3}'

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	DB_NAME=""
	let LOOP=${LOOP}-1
	echo ""

	# Confirm the selection
	until [ -n "${DB_NAME}" ]
	do
		echo -n " Enter Database Name > "
		read DB_NAME

		# Confirm DB_NAME is set
		if [ "${DB_NAME}" = "" ];then
			true

		# Confirm DB_NAME is not quit
		elif [ `echo ${DB_NAME} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0

		# Confirm DB_NAME is a Number
		elif [ `echo ${DB_NAME} | grep -c "[^0-9]"` -eq 1 ] ;then

        		echo " Invalid selection, ${DB_NAME}"
			DB_NAME=""
        		sleep 1
			echo ""

		# Confirm DB_NAME is not greater than $LOOP and not equal to 0
		elif [ ${DB_NAME} -gt ${LOOP} -o ${DB_NAME} -eq 0 ] ;then

        		echo " Invalid selection, ${DB_NAME}"
			DB_NAME=""
        		sleep 1
			echo ""
		else
        		VALID=TRUE
			DB_NAME=`echo ${DB_NAMES[${DB_NAME}]} | awk '{print $1}'`

			# Confirm DB_NAME is set properly
			if [ "${DB_NAME}" = "" ];then
				echo ""
				echo " Error: Problem setting the Database Name"
				exit 1
			fi
		fi
	done
}

# Function to Select/Set Remote HOST Name
###########################################################################
SET_REMOTE_HOST_NAME () 
{
	# set -x

	LOOP=1
	echo ""
	echo " **********************"
	echo " * Select Remote Host *"
	echo " **********************"
	echo ""
	while [ ${REMOTE_HOST_NAMES[${LOOP}]} ]
	do
		echo " ${LOOP} > ${REMOTE_HOST_NAMES[${LOOP}]}" | awk '{printf"%3-s%2-s%1-s\n", " "$1,$2,$3}'

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	NODE_NAME=""
	let LOOP=${LOOP}-1
	until [ -n "${NODE_NAME}" ]
	do
		echo -n " Enter selection > "
		read NODE_NAME

		# Confirm NODE_NAME is not quit
		if [ `echo ${NODE_NAME} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0

		# Confirm NODE_NAME is a Number
		elif [ `echo ${NODE_NAME} | grep -c "[^0-9]"` -eq 1 ] ;then

        		echo " Invalid selection, ${NODE_NAME}"
			NODE_NAME=""
        		sleep 1
			echo ""

		# Confirm NODE_NAME is not greater than $LOOP and not equal to 0
		elif [ ${NODE_NAME} -gt ${LOOP} -o ${NODE_NAME} -eq 0 ] ;then

        		echo " Invalid selection, ${NODE_NAME}"
			NODE_NAME=""
        		sleep 1
			echo ""
		else
        		VALID=TRUE
			NODE_NAME=${REMOTE_HOST_NAMES[${NODE_NAME}]}
		fi
	done
}

# Function to Select/set LOCAL_REMOTE variable
###########################################################################
SET_LOCAL_REMOTE () 
{
	# set -x

	if [ "$1" = CHECK ];then
		MESSAGE=" * Compare ${RESOURCE} on ${HOST} to *"
	elif [ "$1" = EXPORT ];then
		MESSAGE=" * Generate ${RESOURCE} file on *"
	elif [ "$1" = IMPORT ];then
		MESSAGE=" * Import ${HOST} ${RESOURCE} file to *"
	else
		MESSAGE=" * Select where to ${FUNCTION} ${RESOURCE} *"
	fi

	VALID=""
	until [ -n "${VALID}" ]
	do
		echo ""
		echo ""
		echo " ****************************${BANNER}"
		echo "${MESSAGE}" 
		echo " ****************************${BANNER}"
		echo ""
		echo " 1> This Node"
		echo " 2> Remote Node"
		echo " 3> All Nodes"
	
		LOCAL_REMOTE=""
		until [ -n "${LOCAL_REMOTE}" ]
		do
			echo -n " Enter selection > "
			read LOCAL_REMOTE
		done

		case ${LOCAL_REMOTE} in
	
			1) #  Local Node
			VALID=TRUE
			LOCAL_REMOTE=LOCAL
			NODE_NAME=${HOST}
			;;

			2) # Remote Node
			VALID=TRUE
			LOCAL_REMOTE=REMOTE
			SET_REMOTE_HOST_NAME
			;;

			3) # All Nodes
			# Confirm RESOURCE is NOT Everything
			VALID=TRUE
			LOCAL_REMOTE=ALL
			NODE_NAME=ALL
			;;

			"") true
			;;

			q|Q|quit|Quit)
			exit 0
			;;

			*) 
			echo " Invalid selection, ${LOCAL_REMOTE}"
			LOCAL_REMOTE=""
			sleep 1
			;;
		esac
	done
}

# Function to List Database Names, and the nodes they are running them
###########################################################################
LIST_DB_NAMES () 
{
	# set -x

	LOOP=1
	echo ""
	echo ""
	echo " ********************************************"
	echo " * Database Names and the nodes they run on *"
	echo " ********************************************"
	echo ""
	while [ "${DB_NAMES[${LOOP}]}" ]
	do

		# Set DB_NAME using the array ${DB_NAMES}
		DB_NAME=`echo ${DB_NAMES[${LOOP}]} | awk '{print $1}'`

		COUNT=1
		NODES=""
		while [ "${INSTANCE_NAMES[${COUNT}]}" ]
		do
			INSTANCE_NAME=`echo ${INSTANCE_NAMES[${COUNT}]} | awk '{print $1}'`
			DB_HOST=`echo ${INSTANCE_NAMES[${COUNT}]} | awk '{print $4}'`
			if [ `echo ${INSTANCE_NAMES[${COUNT}]} |  awk '{print $1}' | 
					grep -c ${DB_NAME}` -eq 1 ];then
				if [ "${NODES}" = "" ];then
					NODES="${DB_HOST}"
				else
					NODES="${DB_HOST}, ${NODES}"
				fi
			fi

			# Increment COUNT
			let COUNT=${COUNT}+1

		done

		echo " *  ${DB_NAME},	${NODES}" 

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
	echo ""
	echo ""
}

# Function to List Instance Names, and the nodes they are running them
###########################################################################
LIST_INSTANCE_NAMES () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***********************************************************************"
	echo " * Instance Names, Status of Instance in CRS and the node it runs on   *"
	echo " ***********************************************************************"
	echo ""
	while [ "${INSTANCE_NAMES[${LOOP}]}" ]
	do

		INSTANCE_NAME=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $1}'`
		CRS_INSTANCE_STATUS=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $2}'`
		REAL_INSTANCE_HOST=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $3}'`
		ASSIGNED_INSTANCE_HOST=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $4}'`

		# Assign either Green or Red to CRS_STATUS_COLOR based on ${CRS_INSTANCE_STATUS}
		if [ ${CRS_INSTANCE_STATUS} = running ];then
			CRS_STATUS_COLOR=${SETCOLOR_GREEN}
		else
			CRS_STATUS_COLOR=${SETCOLOR_RED}
		fi

		# Assign either Green or Red to INSTANCE_HOST_COLOR based on ${REAL_INSTANCE_HOST}
		if [ "${ASSIGNED_INSTANCE_HOST}" = "${REAL_INSTANCE_HOST}" ];then
			INSTANCE_HOST_COLOR=${SETCOLOR_GREEN}
		else
			INSTANCE_HOST_COLOR=${SETCOLOR_RED}
		fi


		# Print the following as a single line
		${SETCOLOR_NORMAL}
		echo -n " *  ${INSTANCE_NAME},"  | awk '{printf"%2-s%30-s", $1,$2}'
		${CRS_STATUS_COLOR} 
		echo -n "${CRS_INSTANCE_STATUS}," | awk '{printf"%12-s", $1}'
		${INSTANCE_HOST_COLOR} 
		echo "${REAL_INSTANCE_HOST}" | awk '{printf"%9-s\n", $1}'
		${SETCOLOR_NORMAL}

		# Increment LOOP
		let LOOP=${LOOP}+1
	done | more
	echo ""
	echo ""

}

# Function to List Listener Names, and the nodes they are running them
###########################################################################
LIST_LISTENER_NAMES () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***********************************************************************"
	echo " * Listener Names, Status of Listener in CRS and the node it runs on   *"
	echo " ***********************************************************************"
	echo ""
	while [ "${LISTENER_NAMES[${LOOP}]}" ]
	do

		LISTENER_NAME=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $1}'`
		CRS_LISTENER_STATUS=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $2}'`
		REAL_LISTENER_HOST=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $3}'`
		ASSIGNED_LISTENER_HOST=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $4}'`

		# Assign either Green or Red to CRS_STATUS_COLOR based on ${CRS_LISTENER_STATUS}
		if [ ${CRS_LISTENER_STATUS} = ONLINE ];then
			CRS_STATUS_COLOR=${SETCOLOR_GREEN}
		else
			CRS_STATUS_COLOR=${SETCOLOR_RED}
		fi


		# Assign either Green or Red to LISTENER_HOST_COLOR based on ${REAL_LISTENER_HOST}
		if [ ${ASSIGNED_LISTENER_HOST} = ${REAL_LISTENER_HOST} ];then
			LISTENER_HOST_COLOR=${SETCOLOR_GREEN}
		else
			LISTENER_HOST_COLOR=${SETCOLOR_RED}
		fi


		# Print the following as a single line
		${SETCOLOR_NORMAL}
		echo -n " *  ${LISTENER_NAME},"  | awk '{printf"%2-s%30-s", $1,$2}'
		${CRS_STATUS_COLOR} 
		echo -n "${CRS_LISTENER_STATUS}," | awk '{printf"%12-s", $1}'
		${LISTENER_HOST_COLOR} 
		echo "${REAL_LISTENER_HOST}" | awk '{printf"%9-s\n", $1}'
		${SETCOLOR_NORMAL}

		# Increment LOOP
		let LOOP=${LOOP}+1
	done | more
	echo ""
	echo ""
}

# Function to List Service Names, and to list what nodes are running them
###########################################################################
LIST_SERVICE_NAMES () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***********************************************************************"
	echo " * Service Names, Status of Service in CRS and the node it runs on     *"
	echo " ***********************************************************************"
	echo ""
	while [ "${SERVICE_NAMES[${LOOP}]}" ]
	do

		SERVICE_NAME=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $1}'`
		CRS_SERVICE_STATUS=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $2}'`
		REAL_SERVICE_HOST=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $3}'`
		ASSIGNED_SERVICE_HOST=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $4}'`

		# Assign either Green or Red to CRS_STATUS_COLOR based on ${CRS_SERVICE_STATUS}
		if [ ${CRS_SERVICE_STATUS} = ONLINE ];then
			CRS_STATUS_COLOR=${SETCOLOR_GREEN}
		else
			CRS_STATUS_COLOR=${SETCOLOR_RED}
		fi

		# Assign either Green or Red to INSTANCE_HOST_COLOR based on ${REAL_DB_HOST}
		if [ ${ASSIGNED_SERVICE_HOST} = ${REAL_SERVICE_HOST} ];then
			SERVICE_HOST_COLOR=${SETCOLOR_GREEN}
		else
			SERVICE_HOST_COLOR=${SETCOLOR_RED}
		fi

		# Print the following as a single line
		${SETCOLOR_NORMAL}
		echo -n " *  ${SERVICE_NAME},"  | awk '{printf"%2-s%30-s", $1,$2}'
		${CRS_STATUS_COLOR} 
		echo -n "${CRS_SERVICE_STATUS}," | awk '{printf"%12-s", $1}'
		${SERVICE_HOST_COLOR} 
		echo "${REAL_SERVICE_HOST}" | awk '{printf"%9-s\n", $1}'
		${SETCOLOR_NORMAL}

		# Increment LOOP
		let LOOP=${LOOP}+1
	done | more
	echo ""
	echo ""
}


# Function to List the bootup status of CRS, will CRS restart following a reboot
###########################################################################
LIST_CRS_START_STATUS () {

	# set -x

	echo ""
	echo " ***********************************************************************"
	echo " * Host Names, Will CRS Start following a reboot ?                     *"
	echo " ***********************************************************************"
	echo ""

	for REMOTE_NODE_NAME in `crsctl status resource -t | sed -n '/ora.asm/,/ora\./p' |
		grep -v "^ora\."  | awk '{print $3}' | sort`
	do
	
		# If ${LOCAL_REMOTE} = REMOTE & REMOTE_NODE_NAME != NODE_NAME 
		# move on to next REMOTE_NODE_NAME
		[ ${LOCAL_REMOTE} != ALL -a ${REMOTE_NODE_NAME} != ${NODE_NAME} ] && continue

		# Set NODE_NAME to REMOTE_NODE_NAME
		NODE_NAME=${REMOTE_NODE_NAME}

		# Confirm ${NODE_NAME} is up
		if [ ${REMOTE_NODE_NAME} != ${HOST} ];then
			REMOTE_UP ${NODE_NAME}
			if [ ${UP_DOWN} = DOWN ];then
				CRS_RESTART=UNKNOWN
			else
				CRS_RESTART=`ssh -q ic-${REMOTE_NODE_NAME} strings /etc/oracle/scls_scr/${REMOTE_NODE_NAME}/root/crsstart`
			fi
		else
				CRS_RESTART=`strings /etc/oracle/scls_scr/${HOST}/root/crsstart`
		fi

		# Reset CRS_RESTART
		if [ ${CRS_RESTART} = enable ];then
			CRS_RESTART=YES
		elif [ ${CRS_RESTART} = UNKNOWN ];then
			CRS_RESTART=UNKNOWN
		else
		 	CRS_RESTART=NO
		fi

		# Assign either Green or Red to CRS_RESTART based on the value of $CRS_RESTART
		if [ ${CRS_RESTART} = YES ];then
			CRS_RESTART_STATUS_COLOR=${SETCOLOR_GREEN}
		else
			CRS_RESTART_STATUS_COLOR=${SETCOLOR_RED}
		fi

		# Print the following as a single line
		${SETCOLOR_NORMAL}
		echo -n " *  ${REMOTE_NODE_NAME}," | awk '{printf"%2-s%30-s", $1,$2}'
		${CRS_RESTART_STATUS_COLOR} 
		echo "${CRS_RESTART}"
		${SETCOLOR_NORMAL}
	done | more
}

# Function to List VIP Names, and to list what nodes are running them
###########################################################################
LIST_VIP_NAMES () 
{
	# set -x

	LOOP=1
	echo ""
	echo " ***********************************************************************"
	echo " * VIP Names, Status of Service in CRS and the node it runs on         *"
	echo " ***********************************************************************"
	echo ""
	while [ "${VIP_NAMES[${LOOP}]}" ]
	do

		VIP_NAME=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $1}'`
		CRS_VIP_STATUS=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $2}'`
		REAL_VIP_HOST=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $3}'`
		ASSIGNED_VIP_HOST=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $4}'`

		# Assign either Green or Red to CRS_STATUS_COLOR based on ${CRS_VIP_STATUS}
		if [ ${CRS_VIP_STATUS} = ONLINE ];then
			CRS_STATUS_COLOR=${SETCOLOR_GREEN}
		else
			CRS_STATUS_COLOR=${SETCOLOR_RED}
		fi

		# Assign either Green or Red to INSTANCE_HOST_COLOR based on ${REAL_VIP_HOST}
		if [ ${ASSIGNED_VIP_HOST} = ${REAL_VIP_HOST} ];then
			VIP_HOST_COLOR=${SETCOLOR_GREEN}
		else
			VIP_HOST_COLOR=${SETCOLOR_RED}
		fi

		# Print the following as a single line
		${SETCOLOR_NORMAL}
		echo -n " *  ${VIP_NAME},"  | awk '{printf"%2-s%30-s", $1,$2}'
		${CRS_STATUS_COLOR} 
		echo -n "${CRS_VIP_STATUS}," | awk '{printf"%12-s", $1}'
		${VIP_HOST_COLOR} 
		echo "${REAL_VIP_HOST}" | awk '{printf"%9-s\n", $1}'
		${SETCOLOR_NORMAL}

		# Increment LOOP
		let LOOP=${LOOP}+1
	done | more
	echo ""
	echo ""
}

# Function to Start ALL Instances
###########################################################################
START_INSTANCES () 
{
	# set -x
	NODE=$1
				
	echo ""
	echo "********************************************"
	echo "*      Starting Instances on ${NODE}      *"
	echo "********************************************"
	echo ""

	LOOP=1
	while [ "${INSTANCE_NAMES[${LOOP}]}" ]
	do

		INSTANCE_NAME=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $1}'`
		INSTANCE_NUM=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\2/'`

		# Start only resources on ${NODE}
		[ ${INSTANCE_NUM} != ${NODE_NUMBER} ] && continue 

		DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`
		echo " ${PROG}: Using the following command to start instance"
		echo " srvctl start instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
		srvctl start instance -d ${DB_NAME} -i ${INSTANCE_NAME}
		echo ""		

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
}

# Function to Start ALL LISTENERS
###########################################################################
START_LISTENERS () 
{
	# set -x
	NODE=$1

	echo ""
	echo "********************************************"
	echo "*      Starting Listeners on ${NODE}      *"
	echo "********************************************"
	echo ""

	LOOP=1
	while [ "${LISTENER_NAMES[${LOOP}]}" ]
	do

		LISTENER_NAME=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $1}'`
		LISTENER_NUM=`echo ${LISTENER_NAME} | awk -F_ '{print $3}' | sed 's/\(.*\)\([1-9]$\)/\2/'`

		# Start only resources on ${NODE}
		[ ${LISTENER_NUM} != ${NODE_NUMBER} ] && continue 

		echo " ${PROG}: Using the following command to start listener"
		echo " srvctl start listener -n ${NODE} -l ${LISTENER_NAME}"
		srvctl start listener -n ${NODE} -l ${LISTENER_NAME}
		echo ""		

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
}

# Function to Start ALL SERVICES
###########################################################################
START_SERVICES () 
{
	# set -x
	NODE=$1
				
	echo ""
	echo "********************************************"
	echo "*      Starting Services on ${NODE}       *"
	echo "********************************************"
	echo ""

	LOOP=1
	while [ "${SERVICE_NAMES[${LOOP}]}" ]
	do
		SERVICE_NAME=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $1}' | awk -F. '{print $1}'`
		DB_NAME=`echo ${SERVICE_NAME} | tr '[A-Z]' '[a-z]' | sed 's/svc_//'`
		ASSIGNED_HOST_NAME=`echo ${SERVICE_NAMES[${LOOP}]} | awk '{print $4}'`

		# Start only resources on ${NODE}
		[ ${ASSIGNED_HOST_NAME} != ${NODE} ] && continue

		echo " ${PROG}: Using the following command to start service"
		echo " srvctl start service -d ${DB_NAME} -s ${SERVICE_NAME} -i ${DB_NAME}${NODE_NUMBER}"
		srvctl start service -d ${DB_NAME} -s ${SERVICE_NAME} -i ${DB_NAME}${NODE_NUMBER}
		echo ""

		# Increment LOOP
		let LOOP=${LOOP}+1
	done
}

# Function to Start VIP
###########################################################################
START_VIP () 
{
	# set -x
	NODE=$1
			
	echo ""
	echo "****************************************"
	echo "*      Starting VIP on ${NODE}        *"
	echo "****************************************"
	echo ""
	echo " ${PROG}: Using the following command to start VIP"

	VIP_RESOURCE="ora.${NODE}.vip"
	echo "  crs_start ${VIP_RESOURCE}"
	crs_start ${VIP_RESOURCE}
}

# Function to Stop ALL Listeners
###########################################################################
STOP_LISTENERS () 
{
	# set -x
	NODE=$1

	# Listener Section
	GET_LISTENER_NAMES
	echo " ************************************************"
	echo " *        Stopping Listeners on ${NODE}        *"
	echo " ************************************************"
	echo ""

	# Loop through each LISTENER_NAME on $NODE_NAME
	LOOP=1
	while [ "${LISTENER_NAMES[${LOOP}]}" ]
	do
		# Set LISTENER_NAME and NODE_NAME
		LISTENER_NAME=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $1}'`

		# Increment LOOP
		let LOOP=${LOOP}+1

		echo " ${PROG}: Using the following commands"
		# Determine if crsctl stop should be run locally or not
		if [ ${LOCAL_REMOTE} = LOCAL ];then

			echo " srvctl stop listener -n ${NODE_NAME} -l ${LISTENER_NAME}"
			srvctl stop listener -n ${NODE_NAME} -l ${LISTENER_NAME}
			echo ""
		else

			# Confirm ${NODE_NAME} is up
			REMOTE_UP ${NODE_NAME}
			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS"
				echo ""
			else
				echo " srvctl stop listener -n ${NODE_NAME} -l ${LISTENER_NAME}"
				srvctl stop listener -n ${NODE_NAME} -l ${LISTENER_NAME}
				echo ""

			fi
		fi
	done
}

# Function to Stop ALL Instances
###########################################################################
STOP_INSTANCES () 
{
	# set -x
	NODE=$1

	# Instance Section
	GET_INSTANCE_NAMES
	echo " ************************************************"
	echo " *        Stopping Instances on ${NODE}        *"
	echo " ************************************************"
	echo ""

	LOOP=1
	while [ "${INSTANCE_NAMES[${LOOP}]}" ]
	do
		# Set INSTANCE_NAME and DB_NAME
		INSTANCE_NAME=`echo ${INSTANCE_NAMES[${LOOP}]} | 
			awk '{print $1}'`

		# Increment LOOP
		let LOOP=${LOOP}+1

		# Set DB_NAME using INSTANCE_NAME
		DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`

		echo " ${PROG}: Using the following commands"
		# Determine if crsctl stop should be run locally or not
		if [ ${LOCAL_REMOTE} = LOCAL ];then

			echo " srvctl stop instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
			srvctl stop instance -d ${DB_NAME} -i ${INSTANCE_NAME}
			echo ""
		else

			# Confirm ${NODE_NAME} is up
			REMOTE_UP ${NODE_NAME}
			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS"
			else
				echo " srvctl stop instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
				srvctl stop instance -d ${DB_NAME} -i ${INSTANCE_NAME}
				echo ""

			fi
		fi
	done
}

# Function to Stop VIP
###########################################################################
STOP_VIP () 
{
	# set -x
	NODE=$1

	echo " ************************************************"
	echo " *        Stopping VIP on ${NODE}              *"
	echo " ************************************************"
	echo ""

	GET_VIP_NAMES
	# Set VIP_NAME
	LOOP=1
	while [ "${VIP_NAMES[${LOOP}]}" ]
	do

		if [ "${NODE_NAME}" = `echo ${VIP_NAMES[${LOOP}]} | 
				awk '{print $4}'` ];then
			VIP_NAME=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $1}'`
			break
		fi
	done

	# Confirm ${NODE_NAME} is up
	REMOTE_UP ${NODE}
	if [ ${UP_DOWN} = DOWN ];then
		echo ""
		echo " Note: Remote node ${NODE} is down, unable to stop VIP on ${NODE}"
	else
		echo " ${PROG}: Using the following command"
		echo " crs_stop -f ${VIP_NAME}"
		echo ""
		crs_stop -f ${VIP_NAME}
	fi
}

# Function to support Stop CRS
###########################################################################
STOP_CRS () 
{
	# set -x
	NODE=$1

	# CRS Section
	echo " **************************************************"
	echo " *        Stopping CRS on ${NODE}                *"
	echo " **************************************************"
	echo ""

	echo ""
	echo " ${PROG}: Using the following commands"

	# Determine if crsctl stop should be run locally or not
	if [ ${LOCAL_REMOTE} = LOCAL ];then

		echo " crsctl stop crs"
		crsctl stop crs
	else

		# Confirm ${NODE_NAME} is up
		REMOTE_UP ${NODE_NAME}
		if [ ${UP_DOWN} = DOWN ];then
			echo ""
			echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS"
		else
			echo " ssh ic-${NODE_NAME} crsctl stop crs"
			ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl stop crs"
		fi

	fi
}

# Function to Confirm emcpower device is not being used
###########################################################################
CHECK_EMCPOWER () 
{
	# set -x

	# Set EMCPOWER_DEVICE to the 1st argument
	EMCPOWER_DEVICE=$1
	EMCPOWER_USED=NO

	# Confirm $EMCPOWER_DEVICE is set
	if [ "${EMCPOWER_DEVICE}" = "" ];then
		echo ""
		echo "Error: the required variable \"EMCPOWER_DEVICE\" not set"
		echo ""
		exit
	fi
		
	# Display usage info
	echo ""
	echo " Checking to confirm ${EMCPOWER_DEVICE} is not in use on ${NODE_NAME}"
	echo ""

	# Check to confirm $EMCPADM_DEVICE not in use
	if [ ${LOCAL_REMOTE} = LOCAL ];then

		# Confirm ${EMCPOWER_DEVICE} exist on ${NODE_NAME}
		if [ `ls  /dev/${EMCPOWER_DEVICE} 2>/dev/null | wc -l` -eq 0 ]; then

			echo ""
			echo "Error: The device /dev/${EMCPOWER_DEVICE} does not exist on ${NODE_NAME}"
			echo ""
			exit

		# Confirm it's not already in ASM
		elif [ `oracleasm listdisks | tr '[A-Z]' '[a-z]' | 

			grep -c "^${EMCPOWER_DEVICE}1"` -eq 1 ];then	
			echo ""
			echo "Note: ${EMCPOWER_DEVICE} in use by ASM on ${HOST}"
			EMCPOWER_USED=YES

		# Confirm it's not mounted
		elif [ `grep -c "^/dev/${EMCPOWER_DEVICE}. " /etc/mtab` -eq 1 ];then

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} mounted on ${HOST}"
			EMCPOWER_USED=YES

		# Confirm not in /etc/fstab
		elif [ `grep -c "^/dev/${EMCPOWER_DEVICE}. " /etc/fstab` -eq 1 ];then

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} listed in /etc/fstab file on ${HOST}"
			EMCPOWER_USED=YES

		# Confirm it's not being used to support a local swap partition 
		elif [ `swapon -s | grep -c "^/dev/${EMCPOWER_DEVICE}. "` -eq 1 ];then

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} in use by swap on ${HOST}"
			EMCPOWER_USED=YES

		# Confirm this device does is not partioned already
		elif [ `fdisk -l /dev/${EMCPOWER_DEVICE} 2>&1 | grep -c "^/dev/emcpower"` -ge 1 ];then 

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} already partitioned on ${HOST}"
			EMCPOWER_USED=YES
		fi
	else
		# Confirm ${EMCPOWER_DEVICE} exist on ${NODE_NAME}
		if [ `ssh -q ic-${NODE_NAME} ls /dev/${EMCPOWER_DEVICE} 2>/dev/null | wc -l` -eq 0 ];then	

			echo ""
			echo "Error: The device /dev/${EMCPOWER_DEVICE} does not exist on ${NODE_NAME}"
			echo ""
			exit

		# Confirm it's not already in ASM on ${NODE_NAME}
		elif [ `ssh -q ic-${NODE_NAME} . /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm listdisks | tr '[A-Z]' '[a-z]' | grep -c "^${EMCPOWER_DEVICE}"` -eq 1 ];then	

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} in use by ASM on ${NODE_NAME}"
			EMCPOWER_USED=YES

		# Confirm it's not mounted on ${NODE_NAME}
		elif [ `ssh -q ic-${NODE_NAME} grep -c "^/dev/${EMCPOWER_DEVICE} " /etc/mtab` -eq 1 ];then

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} mounted ${NODE_NAME}"
			EMCPOWER_USED=YES

		# Confirm not in /etc/fstab on ${NODE_NAME}
		elif [ `ssh -q ic-${NODE_NAME} grep -c "^/dev/${EMCPOWER_DEVICE} " /etc/fstab` -eq 1 ];then

			echo ""
			echo "Note: ${EMCPOWER_DEVICE} listed in /etc/fstab on ${NODE_NAME}"
			EMCPOWER_USED=YES

		# Confirm it's not being used to support a local swap partition on ${NODE_NAME}
		elif [ `ssh -q ic-${NODE_NAME} /sbin/swapon -s | 

			grep -c "^/dev/${EMCPOWER_DEVICE} "` -eq 1 ];then
			echo ""
			echo "Note: ${EMCPOWER_DEVICE} in use by swap on ${NODE_NAME}"
			EMCPOWER_USED=YES

		# Confirm this device does is not partioned already
		elif [ `ssh -q  ic-${NODE_NAME} /sbin/fdisk -l /dev/${EMCPOWER_DEVICE} 2>&1 | 

			grep -c "^/dev/emcpower"` -ge 1 ];then
			echo ""
			echo "Note: ${EMCPOWER_DEVICE_NO_PARTS} has no partition 1 on ${NODE_NAME}"
			EMCPOWER_USED=YES
		fi
	fi
}

# Function to select emcpower device name
###########################################################################
SELECT_EMCPOWER ()
{
	# set -x
	LOOP=1
	REMOVE_DEVICES=""

	# Clear all old entrys in EMCPOWER_DEVICES
	unset EMCPOWER_DEVICES[*]

	# Build the array EMCPOWER_DEVICES
	###########################################################################
	if [ "${STORAGE_FUNCTION}" = CREATE ];then

		REBUILD_ARRAY=YES

		# Look for emcpower devices that are not already being used
		echo ""
		echo " Checking for available devices on ${HOST}"
		for EMCPOWER_DEVICE in `powermt display dev=all | grep 'Pseudo name' | 
			awk -F= '{print $2}' | sort`
		do

			# Confirm it's not already in ASM
			if [ `oracleasm listdisks | tr '[A-Z]' '[a-z]' | grep -c "^${EMCPOWER_DEVICE}1"` -eq 1 ];then	
				continue

			# Confirm it's not mounted
			elif [ `grep -c "^/dev/${EMCPOWER_DEVICE}. " /etc/mtab` -eq 1 ];then
				continue

			# Confirm not in /etc/fstab
			elif [ `grep -c "^/dev/${EMCPOWER_DEVICE}. " /etc/fstab` -eq 1 ];then
				continue

			# Confirm it's not being used to support a local swap partition 
			elif [ `swapon -s | grep -c "^/dev/${EMCPOWER_DEVICE}. "` -eq 1 ];then
				continue

			# Confirm this device has a partition 1, and nothing else
			elif [ `fdisk -l /dev/${EMCPOWER_DEVICE} 2>/dev/null | grep -c "^/dev/${EMCPOWER_DEVICE}1"` -eq 0 -o `fdisk -l /dev/${EMCPOWER_DEVICE} 2>/dev/null | egrep -c "^/dev/${EMCPOWER_DEVICE}[2-9]"` -ge 1 ];then 
				continue
			fi

			# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
			EMCPOWER_DEVICES[${LOOP}]="${EMCPOWER_DEVICE}1"

			# Increment LOOP
			let LOOP=${LOOP}+1
		done

		# Confirm LOOP is not still set to 1, if it is, 
		# no emcpower devive names have been added
		if [ ${LOOP} -eq 1 ];then
	
			echo ""
			echo " Note: No new emcpower devices to be created"
			echo ""
			exit
		fi

	elif [ "${STORAGE_FUNCTION}" = DELETE ];then

		REBUILD_ARRAY=YES

		for EMCPOWER_DEVICE in `oracleasm listdisks`
		do

			# Confirm $EMCPOWER_DEVICE is not listed in the array $ASM_USED_DISKS
			ASM_LOOP=1
			ADD_DISK=YES
			while [ "${ASM_USED_DISKS[${ASM_LOOP}]}" ]
			do
				if [ ${EMCPOWER_DEVICE} = ${ASM_USED_DISKS[${ASM_LOOP}]} ];then 
					ADD_DISK=NO
					let ASM_LOOP=${ASM_LOOP}+1
					break
				else
					let ASM_LOOP=${ASM_LOOP}+1
				fi
			done

			if [ ${ADD_DISK} = YES ];then

				# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
				EMCPOWER_DEVICES[${LOOP}]=${EMCPOWER_DEVICE}

				# Increment LOOP
				let LOOP=${LOOP}+1
			fi
		done

		# Confirm LOOP is not still set to 1, if it is, 
		# no emcpower devive names have been added
		if [ ${LOOP} -eq 1 ];then
	
			echo ""
			echo " Note: No unused emcpower devices to be deleted"
			echo ""
			exit
		fi

	elif [ "${STORAGE_FUNCTION}" = PARTITION ];then

		REBUILD_ARRAY=NO

		# Look for emcpower devices that are not already partitoned
		echo ""
         	echo " Checking for un-partitioned PP devices on ${NODE_NAME}"
		if [ ${LOCAL_REMOTE} = LOCAL ];then
			for EMCPOWER_DEVICE in `powermt display dev=all | grep 'Pseudo name' | 
				awk -F= '{print $2}' | sort`
			do
				if [ `fdisk -l /dev/${EMCPOWER_DEVICE} 2>&1 | 
					grep -c "^/dev/emcpower"` -eq 0 ];then
	
					# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
					EMCPOWER_DEVICES[${LOOP}]=${EMCPOWER_DEVICE}
	
					# Increment LOOP
					let LOOP=${LOOP}+1
				fi
			done
		else

			for EMCPOWER_DEVICE in `ssh -q ic-${NODE_NAME} /sbin/powermt display dev=all | 
				grep 'Pseudo name' | awk -F= '{print $2}' | sort`
			do
				if [ `ssh -q ic-${NODE_NAME} /sbin/fdisk -l /dev/${EMCPOWER_DEVICE} \ 
					2>&1 | grep -c "^/dev/emcpower"` -eq 0 ];then
	
					# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
					EMCPOWER_DEVICES[${LOOP}]=${EMCPOWER_DEVICE}
	
					# Increment LOOP
					let LOOP=${LOOP}+1
				fi
			done
		fi

		# Confirm at least 1 device was added
		if [ ${LOOP} -eq 1 ];then

			echo ""
			echo "Note: No un-partitioned emcpower devices found on ${NODE_NAME}"
			echo ""
			CONTINUE=NO

		# Add All-EMCpower-Devices, if there are 2 or more devices listed
		elif [ ${LOOP} -ge 3 ];then
			CONTINUE=YES

			# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
			EMCPOWER_DEVICES[${LOOP}]="All-EMCpower-Devices"
		else
			CONTINUE=YES
		fi

	elif [ "${STORAGE_FUNCTION}" = SFDISK ];then

		REBUILD_ARRAY=NO

		# Look for emcpower devices that do not have partitions
		echo ""
         	echo " Checking for un-partitioned PP devices on ${NODE_NAME}"
		if [ ${LOCAL_REMOTE} = LOCAL ];then
			for EMCPOWER_DEVICE in `powermt display dev=all | grep 'Pseudo name' | 
				awk -F= '{print $2}' | sort`
			do
				if [ `ls /dev/${EMCPOWER_DEVICE}[1-9] 2>/dev/null | 
						wc -l` -eq 0 ];then
	
					# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
					EMCPOWER_DEVICES[${LOOP}]=${EMCPOWER_DEVICE}
	
					# Increment LOOP
					let LOOP=${LOOP}+1
				fi
			done
		else

			for EMCPOWER_DEVICE in `ssh -q ic-${NODE_NAME} /sbin/powermt display dev=all | 
				grep 'Pseudo name' | awk -F= '{print $2}' | sort`
			do
				if [ `ssh -q ic-${NODE_NAME} ls /dev/${EMCPOWER_DEVICE}[1-9] \
					2>/dev/null | wc -l` -eq 0 ];then
	
					# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
					EMCPOWER_DEVICES[${LOOP}]=${EMCPOWER_DEVICE}
	
					# Increment LOOP
					let LOOP=${LOOP}+1
				fi
			done
		fi

		# Confirm at least 1 device was added
		if [ ${LOOP} -eq 1 ];then

			echo ""
			echo "Note: No un-partitioned emcpower devices found on ${NODE_NAME}"
			echo ""
			CONTINUE=NO

		# Add All-EMCpower-Devices, if there are 2 or more devices listed
		elif [ ${LOOP} -ge 3 ];then
			CONTINUE=YES

			# Build the array EMCPOWER_DEVICES, Add $EMCPOWER_DEVICE
			EMCPOWER_DEVICES[${LOOP}]="All-EMCpower-Devices"
		else
			CONTINUE=YES
		fi
	fi

	if [ "${STORAGE_FUNCTION}" = CREATE ];then

		# Confirm that CRS is working properly on remote nodes
		LOOP=1
		while [ "${REMOTE_HOST_NAMES[${LOOP}]}" ]
		do

			# Set NODE_NAME
			NODE_NAME=${REMOTE_HOST_NAMES[${LOOP}]}
			echo ""
			echo  " Checking for available devices on ${NODE_NAME}"

			# Confirm ${NODE_NAME} is up
			REMOTE_UP ${NODE_NAME}
			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down"
				echo
				sleep 1
			else
				EMC_LOOP=1
				while [ "${EMCPOWER_DEVICES[${EMC_LOOP}]}" ]
				do
					# Set EMCPOWER_DEVICE to the emcpower device name
					EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMC_LOOP}]} | 
						awk '{print $1}'`

					# Set EMCPOWER_DEVICE_NO_PARTS to $EMCPOWER_DEVICE 
					# minus the partition name/number 1
					EMCPOWER_DEVICE_NO_PARTS=`echo ${EMCPOWER_DEVICE} | 
						sed 's/1//'`

					# Confirm ${EMCPOWER_DEVICE_NO_PARTS} exist on ${NODE_NAME}
					if [ `ssh -q ic-${NODE_NAME} ls /dev/${EMCPOWER_DEVICE_NO_PARTS} 2>/dev/null | wc -l` -eq 0 ];then	
						echo ""
						echo "Note: /dev/${EMCPOWER_DEVICE_NO_PARTS} does not exist on ${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi

					# Confirm it's not already in ASM on ${NODE_NAME}
					elif [ `ssh -q ic-${NODE_NAME} . /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm listdisks | tr '[A-Z]' '[a-z]' | grep -c "^${EMCPOWER_DEVICE}"` -eq 1 ];then	
						echo ""
						echo "Note: ${EMCPOWER_DEVICE} already listed as ASM ${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi

					# Confirm it's not mounted on ${NODE_NAME}
					elif [ `ssh -q ic-${NODE_NAME} grep -c "^/dev/${EMCPOWER_DEVICE} " /etc/mtab` -eq 1 ];then
						echo ""
						echo "Note: ${EMCPOWER_DEVICE} already mounted ${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi

					# Confirm not in /etc/fstab on ${NODE_NAME}
					elif [ `ssh -q ic-${NODE_NAME} grep -c "^/dev/${EMCPOWER_DEVICE} " /etc/fstab` -eq 1 ];then
						echo ""
						echo "Note: ${EMCPOWER_DEVICE} listed in /etc/fstab on ${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi

					# Confirm it's not being used to support a local swap partition on ${NODE_NAME}
					elif [ `ssh -q ic-${NODE_NAME} /sbin/swapon -s | grep -c "^/dev/${EMCPOWER_DEVICE} "` -eq 1 ];then
						echo ""
						echo "Note: ${EMCPOWER_DEVICE} being used for swap on${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi

					# Confirm this device has a partition 1
					elif [ `ssh -q  ic-${NODE_NAME} /sbin/fdisk -l /dev/${EMCPOWER_DEVICE_NO_PARTS} 2>/dev/null | grep -c "^/dev/${EMCPOWER_DEVICE}"` -eq 0 ];then
						echo ""
						echo "Note: ${EMCPOWER_DEVICE_NO_PARTS} has no partition 1 on ${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi

					# Confirm this device does not have other partitions 
					elif [ `ssh -q ic-${NODE_NAME} /sbin/fdisk -l /dev/${EMCPOWER_DEVICE_NO_PARTS} 2>/dev/null | egrep -c "^/dev/${EMCPOWER_DEVICE_NO_PARTS}[2-9]"` -ge 1 ];then 
						echo ""
						echo "Note: ${EMCPOWER_DEVICE_NO_PARTS} has partitions other than 1 on ${NODE_NAME}"
						if [ "${REMOVE_DEVICES}" = "" ];then
							REMOVE_DEVICES=${EMCPOWER_DEVICE}
						else
							REMOVE_DEVICES="${REMOVE_DEVICES}|${EMCPOWER_DEVICE}"
						fi
					fi
			
					# Increment EMC_LOOP
					let EMC_LOOP=${EMC_LOOP}+1
					echo -n "."
				done
			fi

			# Increment LOOP
			let LOOP=${LOOP}+1
		done
	fi

if [ ${REBUILD_ARRAY} = YES ];then

	# Rebuild the array $EMCPOWER_DEVICES as PP_EMCPOWER_DEVICES
	# Remove $REMOVE_DEVICES as needed
	EMC_LOOP=1
	PP_LOOP=1
	echo ""
	unset PP_EMCPOWER_DEVICES[*]
	if [ "${REMOVE_DEVICES}" != "" ];then

		while [ "${EMCPOWER_DEVICES[${EMC_LOOP}]}" ]
		do
			# Set EMCPOWER_DEVICE to the emcpower device name
			EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMC_LOOP}]} | 
				awk '{print $1}'`

			if [ `echo ${EMCPOWER_DEVICE} | egrep -wc "${REMOVE_DEVICES}"` -eq 0 ];then

				PP_EMCPOWER_DEVICES[${PP_LOOP}]="`echo ${EMCPOWER_DEVICES[${EMC_LOOP}]}`"
			
				# Increment PP_LOOP
				let PP_LOOP=${PP_LOOP}+1
			else
				echo "Removing ${EMCPOWER_DEVICE} from the list of possible devices"
			fi
			
			# Increment EMC_LOOP
			let EMC_LOOP=${EMC_LOOP}+1
		done
	else
		while [ "${EMCPOWER_DEVICES[${EMC_LOOP}]}" ]
		do
			PP_EMCPOWER_DEVICES[${PP_LOOP}]="${EMCPOWER_DEVICES[${EMC_LOOP}]}"
			
			# Increment EMC_LOOP
			let EMC_LOOP=${EMC_LOOP}+1
			
			# Increment PP_LOOP
			let PP_LOOP=${PP_LOOP}+1
		done
	fi

	if [ ${PP_LOOP} -ge 3 -a ${STORAGE_FUNCTION} = CREATE ];then
		PP_EMCPOWER_DEVICES[${PP_LOOP}]="All-EMCpower-Devices"
	fi

	# Set BANNER and STORAGE_FUNC based on ${STORAGE_FUNCTION}
	if [ ${STORAGE_FUNCTION} = CREATE ];then
		BANNER=""
		STORAGE_FUNC="added to"
	elif [ ${STORAGE_FUNCTION} = DELETE ];then
		BANNER="****"
		STORAGE_FUNC="deleted from"
	fi

	LOOP=1
	echo ""
	echo " *****************************************${BANNER}"
	echo " * Select device name to be ${STORAGE_FUNC} ASM *"
	echo " *****************************************${BANNER}"
	echo ""
	while [ "${PP_EMCPOWER_DEVICES[${LOOP}]}" ]
	do

		# Set EMCPOWER_DEVICE to the 1st field of ${EMCPOWER_DEVICES[${LOOP}]}
		EMCPOWER_DEVICE=`echo ${PP_EMCPOWER_DEVICES[${LOOP}]} | awk '{print $1}'`

		echo " ${LOOP} > ${EMCPOWER_DEVICE}"

		# Increment LOOP
		let LOOP=${LOOP}+1
	done

	EMCPOWER_DEVICE=""
	let LOOP=${LOOP}-1

	# Confirm the selection
	until [ -n "${EMCPOWER_DEVICE}" ]
	do
		echo -n " Enter selection > "
		read EMCPOWER_DEVICE

		if [ "${EMCPOWER_DEVICE}" = "" ];then
			true

		# Confirm EMCPOWER_DEVICE is not quit
		elif [ `echo ${EMCPOWER_DEVICE} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
			exit 0
		
		# Confirm EMCPOWER_DEVICE is a Number
		elif [ `echo ${EMCPOWER_DEVICE} | egrep -c '[^0-9]'` -eq 1 ];then
       			echo " Invalid selection, ${EMCPOWER_DEVICE}"
			EMCPOWER_DEVICE=""
       			sleep 1
			echo ""

		# Confirm EMCPOWER_DEVICE is not greater than ${LOOP} and not equal to 0
		elif [ ${EMCPOWER_DEVICE} -gt ${LOOP} -o ${EMCPOWER_DEVICE} -eq 0 ];then
       			echo " Invalid selection, ${EMCPOWER_DEVICE}"
			EMCPOWER_DEVICE=""
       			sleep 1
			echo ""
		else
       			VALID=TRUE
			EMCPOWER_DEVICE=`echo ${PP_EMCPOWER_DEVICES[${EMCPOWER_DEVICE}]} | 
				awk '{print $1}'`

			# Confirm EMCPOWER_DEVICE is set properly
			if [ "${EMCPOWER_DEVICE}" = "" ];then
				echo ""
				echo " Error: Problem setting the emcpower device name"
				exit 1
			fi
		fi
	done
fi
}

# Function to support the RESOURCES for the FUNCTION "OTHER"
###########################################################################
OTHER_RESOURCES () 
{
	# set -x

	# Determine what Resource to Use
	VALID=""
	until [ -n "${VALID}" ]
	do
		echo ""
		echo ""
		echo " *************************${BANNER}"
		echo " * Select Resource to ${FUNCTION} *"
		echo " *************************${BANNER}"
		echo ""
		echo " 1> Instance"
		echo " 2> Service"
		echo " 3> Database"
	
		RESOURCE=""
		until [ -n "${RESOURCE}" ]
		do
			echo -n " Enter selection > "
			read RESOURCE
		done

		case ${RESOURCE} in

			1) # Disable Instance
			RESOURCE=Instance
			BANNER="***${BANNER}"

			# Disable Instance
			if [ ${FUNCTION} = Disable ];then

				VALID=TRUE
				SET_LOCAL_REMOTE
				GET_INSTANCE_NAMES
				SET_INSTANCE_NAME
				DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`

				# Comfirm operation
				ANSWER=""
				ASK ${INSTANCE_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl disable instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl disable instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
				fi
				echo ""

			# Enable Instance
			elif [ ${FUNCTION} = Enable ];then

				VALID=TRUE
				SET_LOCAL_REMOTE
				GET_INSTANCE_NAMES
				SET_INSTANCE_NAME
				DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`

				# Comfirm Operation
				ANSWER=""
				ASK ${INSTANCE_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl enable instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl enable instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
				fi
				echo ""

			# Add Instance
			elif [ ${FUNCTION} = Add ];then

				VALID=TRUE
				SET_LOCAL_REMOTE
				GET_DB_NAMES
				SET_DB_NAME
				NEW_INSTANCE_NAME=`echo ${NODE_NAME} | sed 's/[a-z]//g;s/0//'`
				NEW_INSTANCE_NAME="${DB_NAME}${NEW_INSTANCE_NAME}"

				# Confirm NEW_INSTANCE_NAME is not already in use
				GET_INSTANCE_NAMES
				LOOP=1
				while [ "${INSTANCE_NAMES[${LOOP}]}" ]
				do
					if [ ${NEW_INSTANCE_NAME} = `echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $1}'` ];then
						echo ""
						echo " Error: Instance Name \"${NEW_INSTANCE_NAME}\" already in use"
						echo " Select a different Database Name or different Node Name"
						echo " Database most exist before you can add instances to it"
						echo ""
						exit
					fi

					# Increment LOOP
					let LOOP=${LOOP}+1
				done

				# Comfirm Operation
				ANSWER=""
				ASK ${NEW_INSTANCE_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl add instance -d ${DB_NAME} -i ${NEW_INSTANCE_NAME} -n ${NODE_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl start instance -d ${DB_NAME} -i ${NEW_INSTANCE_NAME} -n ${NODE_NAME}"
				fi
				echo ""

			# Remove Instance
			elif [ ${FUNCTION} = Remove ];then

				VALID=TRUE
				SET_LOCAL_REMOTE
				GET_INSTANCE_NAMES
				SET_INSTANCE_NAME
				DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`

				# Comfirm Operation
				ANSWER=""
				ASK ${INSTANCE_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl remove instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl remove instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
				fi
				echo ""

			# Unregister Instance
			elif [ ${FUNCTION} = Unregister ];then

				VALID=TRUE
				SET_LOCAL_REMOTE
				GET_INSTANCE_NAMES
				SET_INSTANCE_NAME
				DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`

				# Comfirm Operation
				ANSWER=""
				ASK ${INSTANCE_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " crs_unregister ora.${DB_NAME}.${INSTANCE_NAME}.inst"
					echo ""

					# Run crs_unregister as oracle
					su oracle -c "${GRID_HOME}/bin/crs_unregister ora.${DB_NAME}.${INSTANCE_NAME}.inst"
				fi
				echo ""
			fi
			;;

			3) # Database
			VALID=TRUE
			RESOURCE=Database
			BANNER="*****${BANNER}"

			GET_DB_NAMES
			SET_DB_NAME
			NODE_NAME=${HOST}

			# Disable Database
			if [ ${FUNCTION} = Disable ];then

				# Comfirm Operation
				ANSWER=""
				ASK ${DB_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl add database -d ${DB_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl add database -d ${DB_NAME}"
				fi
				echo ""

			# Enable Database
			elif [ ${FUNCTION} = Enable ];then

				# Comfirm Operation
				ANSWER=""
				ASK ${DB_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl enable database -d ${DB_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl enable database -d ${DB_NAME}"
				fi
				echo ""

			# Add Database
			elif [ ${FUNCTION} = Add ];then

				# Ask the name of the DB to ADD
				NEW_DB_NAME=""
				echo ""
				until [ -n "${NEW_DB_NAME}" ]
				do
					echo -n " Enter the Database Name to ${FUNCTION} > "
					read NEW_DB_NAME
			
					case ${NEW_DB_NAME} in
			
        					"") # Do Nothing
        					;;
				
        					q|Q|N|n|NO|no|No) # Exit Now
						exit
        					;;
	
        					*)

						# Confirm Database name is not already in use
						GET_DB_NAMES
						LOOP=1
						while [ "${DB_NAMES[${LOOP}]}" ]
						do
							if [ ${NEW_DB_NAME} = `echo ${DB_NAMES[${LOOP}]} | awk '{print $1}'` ];then
								echo ""
								echo " Error: Database Name \"${NEW_DB_NAME}\" already in use"
								echo " Select a different Database Name"
								echo ""
								NEW_DB_NAME=""
							fi

							# Increment LOOP
							let LOOP=${LOOP}+1
						done
						;;
					esac
				done

				# Comfirm Operation
				ANSWER=""
				ASK ${NEW_DB_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl add database -d ${NEW_DB_NAME} -o ${ORACLE_HOME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl add database -d ${NEW_DB_NAME} -o ${ORACLE_HOME}"
				fi
				echo ""

			# Remove Database
			elif [ ${FUNCTION} = Remove ];then
			
				# Comfirm Operation
				ANSWER=""
				ASK ${DB_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " srvctl remove database -d ${DB_NAME}"
					echo ""

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/srvctl remove database -d ${DB_NAME}"
				fi
				echo ""


			# Unregister Database
			elif [ ${FUNCTION} = Unregister ];then

				# Comfirm Operation
				ANSWER=""
				ASK ${DB_NAME}
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo ""
					echo " crs_unregister ora.${DB_NAME}.db"

					# Run srvctl as oracle
					su oracle -c "${GRID_HOME}/bin/crs_unregister ora.${DB_NAME}.db"
				fi
				echo ""
			fi
			;;

			"") true
			;;

			q|Q|quit|Quit)
			exit 0
			;;

			*) 
			echo " Invalid selection, ${RESOURCE}"
			RESOURCE=""
			sleep 1
			;;
		esac
	done
}

# Function to confirm ASM is not ruuning and no emcpower devices are mounted
###########################################################################
ASM_CHECK () {
	# set -x

	ASM_UP=NO

	# Set ASM_UP to YES if ASM is still running
	if [ ${LOCAL_REMOTE} = LOCAL ];then

		# Confirm ASM is down
		if [ `crsctl status resource ora.asm 2>/dev/null | grep "STATE" |
			grep -c "ONLINE on ${NODE_NAME}"` -eq 1 ];then
			ASM_UP=YES

		# Confirm no emcpower devices are mounted
		elif [ `grep -c emcpower /etc/mtab` -ge 1 ];then
			ASM_UP=YES
		fi

	elif [ ${LOCAL_REMOTE} = REMOTE ];then

		# Confirm ASM is down
		if [ `ssh -q ic-${NODE_NAME} ${GRID_HOME}/bin/crsctl status resource ora.asm 2>/dev/null | 
			grep "STATE" | grep -c "ONLINE on ${NODE_NAME}"` -eq 1 ];then
			ASM_UP=YES

		# Confirm no emcpower devices are mounted
		elif [ `ssh -q ic-${NODE_NAME} grep -c emcpower /etc/mtab` -ge 1 ];then
			ASM_UP=YES
		fi
	fi
}

# Function to confirm all emcpower devices are synced/the same
###########################################################################
EMCPADM_CHECK () {
	# set -x
	DEVICE_MISMATCH=NO
	EMCPADM_LOOP=1
	unset EMCPADM_DIFF[*]	

	# Add the emcpower devices that are different than those in /tmp/emcp_info.${NODE_NAME}
	# to the array EMCPADM_DIFF
	if [ ${LOCAL_REMOTE} = LOCAL ];then

		# Set IFS to end of line
		IFS='
'
		for CHECK_DATA in `emcpadm check_mappings -vf /tmp/emcp_info.${NODE_NAME}`
		do
			IFS=${IFS_ORIG}

			# Display everything if long format
			[ ${EMCPADM_FORMAT} = LONG ] && echo "${CHECK_DATA}"

			# Skip any line that does not start with emcpower
			[ `echo ${CHECK_DATA} | grep -c "^emcpower."` -eq 0 ] && continue

			# Skip any line that contains "no change"
			[ `echo ${CHECK_DATA} | grep -c "no change"` -eq 1 ] && continue

			# Anything making it this far is a device that does not match
			DEVICE_MISMATCH=YES

			# Add $CHECK_DATA to the array EMCPADM_DIFF
			EMCPADM_DIFF[${EMCPADM_LOOP}]="`echo ${CHECK_DATA} | 
				awk '{print $2,$3,$4}'`"

			# Increment EMCPADM_LOOP
			let EMCPADM_LOOP=${EMCPADM_LOOP}+1
		done
	IFS=${IFS_ORIG}

	elif [ ${LOCAL_REMOTE} = REMOTE ];then

		# Set IFS to end of line
		IFS='
'
		for CHECK_DATA in `ssh -q ic-${NODE_NAME} /sbin/emcpadm check_mappings -vf /tmp/emcp_info.${HOST}`
		do
			IFS=${IFS_ORIG}

			# Display everything if long format
			[ ${EMCPADM_FORMAT} = LONG ] && echo "${CHECK_DATA}"

			# Skip any line that does not start with emcpower
			[ `echo ${CHECK_DATA} | grep -c "^emcpower."` -eq 0 ] && continue

			# Skip any line that contains "no change"
			[ `echo ${CHECK_DATA} | grep -c "no change"` -eq 1 ] && continue

			# Anything making it this far is a device that does not match
			DEVICE_MISMATCH=YES

			# Add $CHECK_DATA to the array EMCPADM_DIFF
			EMCPADM_DIFF[${EMCPADM_LOOP}]="`echo ${CHECK_DATA} | 
				awk '{print $2,$3,$4}'`"

			# Increment EMCPADM_LOOP
			let EMCPADM_LOOP=${EMCPADM_LOOP}+1
		done

	fi
	IFS=${IFS_ORIG}
}

echo ""
echo "	*****************************************"
echo "	*     Oracle 11G RAC Admistration Tool  *"
echo "	*        Written By: Jon Swift          *"
echo "	*         ${PROG} Version 3.1            *"
echo "	*****************************************"
echo ""
echo ""
echo ""
sleep 1

# Loop through these questions until DONE is set to DONE
###########################################################################
while [ "${DONE}" != DONE ]
do

# Set/Reset the following variables
###########################################################################
REMOTE_HOST=""
NODE_NAME=""
LOCAL_REMOTE=""
FUNCTION=""
BANNER=""
RESOURCE=""
ALL_SERVICE_NAMES=""
TOTAL_REMOTE_NODES_DOWN=0
TOTAL_REMOTE_NODES=0
LAST_SYSTEM_UP=NO
LOOP=""
COUNT=""
COUNTER=""
unset INSTANCE_NAMES[*]
unset LISTENER_NAMES[*]
unset SERVICE_NAMES[*]
unset DB_NAMES[*]
unset VIP_NAMES[*]
rm -f ${LOCK_FILE}

# Confirm CRS is working on all nodes if needed
if [ ${CHECK_CRS} = YES ];then

	CRS_CHECK

# Determine what Function to perform
###########################################################################
VALID=""
until [ -n "${VALID}" ]
do

	echo ""
	echo " ***************************"
	echo " * Select Primary Function *"
	echo " ***************************"
	echo ""
	echo " 1> Start"
	echo " 2> Stop"
	echo " 3> Status"
	echo " 4> Storage"
	echo " 5> Other"

	FUNCTION=""
	until [ -n "${FUNCTION}" ]
	do
		echo -n " Enter selection > "
		read FUNCTION
	done

	case ${FUNCTION} in
	
		1) # Start
		VALID=TRUE
		FUNCTION=Start
		BANNER='*'
		;;

		2) # Stop
		VALID=TRUE
		FUNCTION=Stop
		;;

		3) # Status
		VALID=TRUE
		FUNCTION=Status
		BANNER='**'
		;;

		4) # STORAGE
		VALID=TRUE
		FUNCTION=Storage
		BANNER='**'
		;;

		5) # Other
		VALID=TRUE
		FUNCTION=Other
		BANNER='*'
		;;

		"") true
		;;

		q|Q|quit|Quit)
		exit 0
		;;

		*) 
		echo " Invalid selection, ${FUNCTION}"
		FUNCTION=""
		sleep 1
		;;
	esac
done

else
	FUNCTION=Storage
	GET_REMOTE_HOST_NAMES
 	BANNER='**'
fi

if [ ${FUNCTION} = Other ];then

# Determine what Function to perform
###########################################################################
VALID=""
until [ -n "${VALID}" ]
do
	echo ""
	echo " ********************************"
	echo " * Select Desired CRS Operation *"
	echo " ********************************"
	echo ""
	echo " 1> Disable Resource     (Instance, Service, Database)  *" 
	echo " 2> Enable Resource      (Instance, Service, Database)  **"
	echo " 3> Add Resource         (Instance, Service, Database)"
	echo " 4> Remove Resource      (Instance, Service, Database)"
	echo " 5> Unregister Resource  (Instance, Service, Database)"
	echo " 6> Relocate Resource    (Move VIP)"
	echo " 7> List all Databases"
	echo " 8> Disable CRS  *"
	echo " 9> Enable CRS   **"
	echo ""
	echo " Note: *   Disable from starting following a reboot"
	echo " Note: **  Enable starting following a reboot"
	echo ""

	OPERATION=""
	FUNCTION=""
	until [ -n "${OPERATION}" ]
	do
		echo -n " Enter selection > "
		read OPERATION
	done

	case ${OPERATION} in
		
		1) # Disable Resource
		FUNCTION=Disable
		VALID=TRUE
		BANNER="****${BANNER}"
		OTHER_RESOURCES
		;;
		
		2) # Enable Resource
		FUNCTION=Enable
		VALID=TRUE
		BANNER="***${BANNER}"
		OTHER_RESOURCES
		;;
	
		3) #  Add Resource
		FUNCTION=Add
		VALID=TRUE
		OTHER_RESOURCES
		;;

		4) # Remove Resource
		FUNCTION=Remove
		VALID=TRUE
		BANNER="***${BANNER}"
		OTHER_RESOURCES
		;;

		5) # Unregister Resource
		FUNCTION=Unregister
		VALID=TRUE
		BANNER="*******${BANNER}"
		OTHER_RESOURCES
		;;

		6) # Relocate Resource
		FUNCTION=Relocate
		RESOURCE="VIP"
		VALID=TRUE
		BANNER="***${BANNER}"
		NODE_NAME=ALL
		GET_VIP_NAMES
		SET_VIP_NAME

		# Confirm Operation
		NODE_NAME="to ${NODE_NAME}"
		
		# Comfirm operation
		ANSWER=""
		ASK ${VIP_NAME}
		if [ "${ANSWER}" = YES ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " crs_relocate -f ${VIP_NAME}"
			crs_relocate -f ${VIP_NAME}
		fi
		echo ""
		;;

		7) # List Databases
		FUNCTION=List
		VALID=TRUE
		BANNER="*${BANNER}"
		NODE_NAME=ALL
		GET_DB_NAMES
		GET_INSTANCE_NAMES Reverse
 		LIST_DB_NAMES
		;;

		8) # Disable CRS starting following reboot
		FUNCTION=Disable
		RESOURCE=CRS
		VALID=TRUE
		BANNER="**${BANNER}"
		SET_LOCAL_REMOTE
		
		# Comfirm operation
		ANSWER=""
		ASK "Following reboot"
		if [ "${ANSWER}" = YES ];then

			echo ""
			echo " ${PROG}: Using the following command"

			# Determine if crsctl disable should be run locally or not
			if [ ${LOCAL_REMOTE} = LOCAL ];then

				echo " crsctl disable crs"
				crsctl disable crs

			elif [ ${LOCAL_REMOTE} = REMOTE ];then

				# Confirm ${NODE_NAME} is up
				REMOTE_UP ${NODE_NAME}
				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS Following reboot"
				else

					echo " ssh ic-${NODE_NAME} crsctl disable crs"
					ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl disable crs"
				fi

			else # ALL

				echo " crsctl disable crs"
				crsctl enable crs

				LOOP=1
				while [ "${REMOTE_HOST_NAMES[${LOOP}]}" ]
				do
			
					# Set NODE_NAME
					NODE_NAME=${REMOTE_HOST_NAMES[${LOOP}]}

					# Confirm ${NODE_NAME} is up
					REMOTE_UP ${NODE_NAME}
					if [ ${UP_DOWN} = DOWN ];then

						echo ""
						echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS Following reboot"
					else

						echo " ssh ic-${NODE_NAME} crsctl disable crs"
						ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl disable crs"
					fi

					# Increment LOOP
					let LOOP=${LOOP}+1
				done
			fi
		fi
		echo ""
		;;

		9) # Enable CRS starting following a reboot
		FUNCTION=Enable
		RESOURCE=CRS
		VALID=TRUE
		BANNER="**${BANNER}"
		SET_LOCAL_REMOTE
		
		# Comfirm operation
		ANSWER=""
		ASK "Following reboot"
		if [ "${ANSWER}" = YES ];then

			echo ""
			echo " ${PROG}: Using the following command"

			# Determine if crsctl enable should be run locally or not
			if [ ${LOCAL_REMOTE} = LOCAL ];then

				echo " crsctl enable crs"
				crsctl enable crs

			elif [ ${LOCAL_REMOTE} = REMOTE ];then

				# Confirm ${NODE_NAME} is up
				REMOTE_UP ${NODE_NAME}
				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS Following reboot"
				else

					echo " ssh ic-${NODE_NAME} crsctl enable crs"
					ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl enable crs"
				fi

			else # ALL

				echo " crsctl disable crs"
				crsctl enable crs

				LOOP=1
				while [ "${REMOTE_HOST_NAMES[${LOOP}]}" ]
				do
			
					# Set NODE_NAME
					NODE_NAME=${REMOTE_HOST_NAMES[${LOOP}]}

					# Confirm ${NODE_NAME} is up
					REMOTE_UP ${NODE_NAME}
					if [ ${UP_DOWN} = DOWN ];then

						echo ""
						echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS Following reboot"
					else

						echo " ssh ic-${NODE_NAME} crsctl enable crs"
						ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl enable crs"
					fi

					# Increment LOOP
					let LOOP=${LOOP}+1
				done
			fi
		fi
		echo ""
		;;

		"") true
		;;

		q|Q|quit|Quit)
		exit 0
		;;

		*) 
		echo " Invalid selection, ${OPERATION}"
		OPERATION=""
		sleep 1
		;;
	esac
done

# STORAGE
###########################################################################
elif [ ${FUNCTION} = Storage ];then

	# Source /local/home/oracle/.asm_setup
	. /local/home/oracle/.asm_setup 2>/dev/null

	# Select STORAGE operation to perform
	###########################################################################
	VALID=""
	until [ -n "${VALID}" ]
	do
		echo ""
		echo ""
		echo " ****************************"
		echo " * Select STORAGE Operation *"
		echo " ****************************"
		echo ""
		echo " 1> Create ASM Disk"
		echo " 2> Delete ASM Disk"
		echo " 3> List ASM Disks"
		echo " 4> Scan ASM Disks"
		echo " 5> Display ASM Disk usage"
		echo " 6> ASM driver status"
		echo " 7> Export EMC PowerPath device mapping"
		echo " 8> Check EMC PowerPath device mapping"
		echo " 9> Import EMC PowerPath device mapping"
		echo " 10> Partition PowerPath device"
		echo " 11> Sfdisk -R PowerPath device"
	
		STORAGE=""
		until [ -n "${STORAGE}" ]
		do
			echo -n " Enter selection > "
			read STORAGE
		done

		case ${STORAGE} in
	
			1) # Create ASM Disk
			VALID=TRUE
			STORAGE_FUNCTION=CREATE
			;;
	
			2) # Delete ASM Disk
			VALID=TRUE
			STORAGE_FUNCTION=DELETE
			;;
	
			3) # List ASM Disks
			VALID=TRUE
			STORAGE_FUNCTION=LIST
			;;
	
			4) # Scan ASM Disks
			VALID=TRUE
			STORAGE_FUNCTION=SCAN
			;;
	
			5) # Display ASM Disk usage
			VALID=TRUE
			STORAGE_FUNCTION=DISPLAY
			;;
	
			6) # ASM driver status
			VALID=TRUE
			STORAGE_FUNCTION=DRIVER
			;;
	
			7) # Export EMC PowerPath device mapping
			VALID=TRUE
			STORAGE_FUNCTION=EXPORT
			;;

			8) # Check EMC PowerPath device mapping
			VALID=TRUE
			STORAGE_FUNCTION=CHECK
			;;
	
	
			9) # Import EMC PowerPath device mapping
			VALID=TRUE
			STORAGE_FUNCTION=IMPORT
			;;

			10) # Partition PowerPath device
			VALID=TRUE
			STORAGE_FUNCTION=PARTITION
			;;

			11) # SFDISK PowerPath device
			VALID=TRUE
			STORAGE_FUNCTION=SFDISK
			;;
	
			q|Q|quit|exit) # Exit Now
			exit
			;;
	
			*) 
			echo -e "\n Invalid selection, ${STORAGE}\n"
			STORAGE=""
			sleep 1
			;;
		esac
	done

	# Perform STORAGE Function
	###############################################################################

	# Create ASM Disk
	if [ ${STORAGE_FUNCTION} = CREATE ];then

		GET_REMOTE_HOST_NAMES
		SELECT_EMCPOWER
		FUNCTION=Create
		RESOURCE="ASM Disk"
		NODE_NAME=${HOST}

		# Create ASM disks for all emcpower dvices listed in the array PP_EMCPOWER_DEVICES
		if [ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ];then
			LOOP=1
			while [ "${PP_EMCPOWER_DEVICES[${LOOP}]}" ]
			do
				# Set EMCPOWER_DEVICE to the emcpower device name
				EMCPOWER_DEVICE=`echo ${PP_EMCPOWER_DEVICES[${LOOP}]} | 
					awk '{print $1}'`
				
				# Increment LOOP
				let LOOP=${LOOP}+1

				# Skip EMCPOWER_DEVICE if it's All-EMCpower-Devices
				[ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ] && continue
	
				# Set ASM_DEVICE to the upper case of $EMCPOWER_DEVICE
				ASM_DEVICE=`echo ${EMCPOWER_DEVICE} | tr '[a-z]' '[A-Z]'`
	
				ASK "\"${ASM_DEVICE}\" using \"/dev/${EMCPOWER_DEVICE}\""
				if [ "${ANSWER}" = YES ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo " oracleasm createdisk ${ASM_DEVICE} /dev/${EMCPOWER_DEVICE}"
					echo ""
					oracleasm createdisk ${ASM_DEVICE} /dev/${EMCPOWER_DEVICE}
					echo ""
					${SETCOLOR_RED}
					echo " Note: You should now run \"oracleasm scandisks\" on other nodes"
					echo " ${PROG} Storage menu option 4"
					${SETCOLOR_NORMAL}
					echo ""
				else
					echo ""
				fi
			done

		# Create ASM disk for ${EMCPOWER_DEVICE}
		else

			# Set ASM_DEVICE to the upper case of $EMCPOWER_DEVICE
			ASM_DEVICE=`echo ${EMCPOWER_DEVICE} | tr '[a-z]' '[A-Z]'`

			ASK "\"${ASM_DEVICE}\" using \"/dev/${EMCPOWER_DEVICE}\""
			if [ "${ANSWER}" = YES ];then

				echo ""
				echo " ${PROG}: Using the following command"
				echo " oracleasm createdisk ${ASM_DEVICE} /dev/${EMCPOWER_DEVICE}"
				echo ""
				oracleasm createdisk ${ASM_DEVICE} /dev/${EMCPOWER_DEVICE}
				echo ""
				${SETCOLOR_RED}
				echo " Note: You should now run \"oracleasm scandisks\" on other nodes"
				echo " ${PROG} Storage menu option 4"
				${SETCOLOR_NORMAL}
				echo ""
			else
				echo ""
			fi
		fi

	# Delete ASM Disk
	elif [ ${STORAGE_FUNCTION} = DELETE ];then

		# Add the ASM disks that belong to ASM disk groups to the array ASM_USED_DISKS
		unset ASM_USED_DISKS[*]	

		LOOP=1
		# Run sqlplus as oracle
		for ASM_USED_DISK in `su oracle -c ". /local/home/oracle/.asm_setup 2>/dev/null; \
			sqlplus -s / as sysasm @/home/oracle/11grac_scripts/used_asm_disks.sql" 2>/dev/null |
			grep EMCPOWER | sed 's{/dev/oracleasm/disks/{{;s{ORCL:{{'`
		do
			# Confirm ASM_USED_DISK is set, and set properly
			if [ "${ASM_USED_DISK}" = "" ];then
				echo ""
				echo "Error: The required variable \"ASM_USED_DISK\" not set"
				echo ""
				exit
			fi

			# Add ASM_USED_DISK to the array ASM_USED_DISKS
			ASM_USED_DISKS[${LOOP}]="${ASM_USED_DISK}"

			# Increment $LOOP
			let LOOP=${LOOP}+1
		done
			
		SELECT_EMCPOWER
		FUNCTION=Delete
		RESOURCE="ASM Disk"
		NODE_NAME=${HOST}

		ASK \"${EMCPOWER_DEVICE}\"
		if [ "${ANSWER}" = YES ];then
	
			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm deletedisk ${EMCPOWER_DEVICE}"
			oracleasm deletedisk ${EMCPOWER_DEVICE}

			echo ""
			${SETCOLOR_RED}
			echo " Note: You should now run \"oracleasm scandisks\" on other nodes"
			echo " ${PROG} Storage menu option 4"
			${SETCOLOR_NORMAL}
			echo ""
		else
			echo ""
		fi
			
	# List ASM Disks
	elif [ ${STORAGE_FUNCTION} = LIST ];then
		SET_LOCAL_REMOTE

		if [ ${LOCAL_REMOTE} = LOCAL ];then
			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm listdisks"
			echo ""
			oracleasm listdisks
			echo ""

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
			else
				echo ""
				echo " ${PROG}: Using the following command"
				echo " ssh -q ic-${NODE_NAME} oracleasm listdisks"
				echo ""
				ssh -q ic-${NODE_NAME} . /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm listdisks
				echo ""
			fi
		else
			# ALL
			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm listdisks"
			echo ""
			oracleasm listdisks
			echo ""

			COUNTER=1
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
				else
					echo ""
					echo " ${PROG}: Using the following command"
					echo " ssh -q ic-${NODE_NAME} oracleasm listdisks"
					echo ""
					ssh -q ic-${NODE_NAME} . /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm listdisks
					echo ""
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# Scan ASM Disks
	elif [ ${STORAGE_FUNCTION} = SCAN ];then

		SET_LOCAL_REMOTE

		if [ ${LOCAL_REMOTE} = LOCAL ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm scandisks"
			echo ""
			oracleasm scandisks
			echo ""

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then
				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
			else
				echo ""
				echo " ${PROG}: Using the following command"
				echo " ssh -q ic-${NODE_NAME} oracleasm scandisks"
				echo ""
				ssh -q ic-${NODE_NAME} . /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm scandisks
				echo ""
			fi
		else
			# ALL
			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm scandisks"
			echo ""
			oracleasm scandisks
			echo ""

			COUNTER=1
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then
					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
				else
					echo ""
					echo " ${PROG}: Using the following command"
					echo " ssh -q ic-${NODE_NAME} oracleasm scandisks"
					echo ""
					ssh -q ic-${NODE_NAME} . /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm scandisks
					echo ""
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# Display ASM Disk usage
	elif [ ${STORAGE_FUNCTION} = DISPLAY ];then

		SET_LOCAL_REMOTE

		# Use the "asmcmd lsdg" command to display ASM disk usage
		if [ ${LOCAL_REMOTE} = LOCAL ];then
			echo ""
			echo " ${PROG}: Using the following command"
			echo " asmcmd lsdg"
			echo ""
			# Run asmcmd as oracle
			su oracle -c ". ~/.asm_setup 2>/dev/null;${GRID_HOME}/bin/asmcmd lsdg"
			echo ""

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then
				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
			else
				echo ""
				echo " ${PROG}: Using the following command"
				echo " ssh -q ic-${NODE_NAME} asmcmd lsdg"
				echo ""
				# Run asmcmd as oracle
				ssh -q ic-${NODE_NAME} "su oracle -c \". /local/home/oracle/.asm_setup 2>/dev/null;${GRID_HOME}/bin/asmcmd lsdg 2>/dev/null\""
				echo ""
			fi
		else
			# ALL
			echo ""
			echo " ${PROG}: Using the following command"
			echo " asmcmd lsdg"
			echo ""
			# Run asmcmd as oracle
			su oracle -c ". ~/.asm_setup 2>/dev/null;${GRID_HOME}/bin/asmcmd lsdg"
			echo ""

			COUNTER=1
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then
					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
				else
					echo ""
					echo " ${PROG}: Using the following command"
					echo " ssh -q ic-${NODE_NAME} asmcmd lsdg"
					echo ""
					# Run asmcmd as oracle
					ssh -q ic-${NODE_NAME} "su oracle -c \". /local/home/oracle/.asm_setup 2>/dev/null;${GRID_HOME}/bin/asmcmd lsdg 2>/dev/null\""
					echo ""
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# ASM driver status	
	# Use the "oracleasm status" command to display ASM driver status
	elif [ ${STORAGE_FUNCTION} = DRIVER ];then

		SET_LOCAL_REMOTE

		if [ ${LOCAL_REMOTE} = LOCAL ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm status"
			echo ""
			oracleasm status
			echo ""

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
			else
				echo ""
				echo " ${PROG}: Using the following command"
				echo " ssh -q ic-${NODE_NAME} oracleasm status"
				echo ""
				ssh -q ic-${NODE_NAME} ". /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm status"
				echo ""
			fi
		else
			# ALL
			echo ""
			echo " ${PROG}: Using the following command"
			echo " oracleasm status"
			echo ""
			oracleasm status
			echo ""

			COUNTER=1
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
				else
					echo ""
					echo " ${PROG}: Using the following command"
					echo " ssh -q ic-${NODE_NAME} oracleasm status"
					echo ""
					ssh -q ic-${NODE_NAME} ". /local/home/oracle/.asm_setup 2>/dev/null;/usr/sbin/oracleasm status"
					echo ""
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# Export EMC PowerPath device mapping
	# Use the command "emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}" 
	# to export the current emcpower device mapping data
	elif [ ${STORAGE_FUNCTION} = EXPORT ];then

		FUNCTION=Export
		RESOURCE="PP device mapping"
		BANNER='***********'
		SET_LOCAL_REMOTE EXPORT

		if [ ${LOCAL_REMOTE} = LOCAL ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
			echo ""
			rm -f /tmp/emcp_info.${NODE_NAME}
			emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
			echo ""

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to generate PowerPath device mapping file"
				echo ""
			else
				echo ""
				echo " ${PROG}: Using the following command"
				echo ""
				echo " ssh -q ic-${NODE_NAME} /sbin/emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
				echo ""
				ssh -q ic-${NODE_NAME} rm -f /tmp/emcp_info.${NODE_NAME}
				ssh -q ic-${NODE_NAME} /sbin/emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
				echo ""
			fi
		else
			# ALL

			NODE_NAME=${HOST}
			echo ""
			echo " ${PROG}: Using the following command"
			echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
			echo ""
			rm -f /tmp/emcp_info.${NODE_NAME}
			emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
			echo ""

			COUNTER=1
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to generate PowerPath device mapping file"
					echo ""
				else
					echo ""
					echo " ${PROG}: Using the following command"
					echo " ssh -q ic-${NODE_NAME} /sbin/emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
					echo ""
					ssh -q ic-${NODE_NAME} rm -f /tmp/emcp_info.${NODE_NAME}
					ssh -q ic-${NODE_NAME} /sbin/emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
					echo ""
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# Check EMC PowerPath device mapping
	# Use the command "emcpadm check_mappings -f /tmp/emcp_info.${NODE_NAME}" 
	# to check the current emcpower device mapping data against $HOST
	elif [ ${STORAGE_FUNCTION} = CHECK ];then

		# Ask to display Short or Long format
		VALID=""
 		until [ -n "${VALID}" ]
 		do

			echo ""
			echo ""
			echo " *****************"
			echo " * Select Format *"
			echo " *****************"
			echo ""
			echo " 1> Short Format"
			echo " 2> Long Format"

			FORMAT=""
			until [ -n "${FORMAT}" ]
			do
				echo -n " Enter selection > "
				read FORMAT
			done

			case ${FORMAT} in

				1) # EMCPADM (Short Format)
				VALID=TRUE
				EMCPADM_FORMAT=SHORT
				;;

				2) # EMCPADM (Long Format)
				VALID=TRUE
				EMCPADM_FORMAT=LONG
				;;

				"") true
				;;

				q|Q|quit|Quit)
				exit 0
				;;

				*)
				echo " Invalid selection, ${FORMAT}"
				FORMAT=""
				sleep 1
				;;		
			esac
		done

		FUNCTION=Check
		RESOURCE="PP device mapping"
		BANNER='****************'
		SET_LOCAL_REMOTE CHECK

		if [ ${LOCAL_REMOTE} = LOCAL ];then

			if [ ${EMCPADM_FORMAT} = LONG ];then

				echo ""
				echo " ${PROG}: Using the following command"
				echo ""
				echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
				echo " emcpadm check_mappings -vf /tmp/emcp_info.${NODE_NAME}"
			fi

			echo ""
			rm -f /tmp/emcp_info.${NODE_NAME}
			emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
			EMCPADM_CHECK

			# Display status
			if [ ${DEVICE_MISMATCH} = NO ];then
				${SETCOLOR_GREEN}
				echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
			else
				${SETCOLOR_RED}
				echo "The following device name(s) on ${NODE_NAME} do not match"
				${SETCOLOR_NORMAL}

				EMCPADM_LOOP=1
				while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
				do
					# Display $EMCPADM_DIFF data
					echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]}

					# Incremnt EMCPADM_LOOP
					let EMCPADM_LOOP=${EMCPADM_LOOP}+1
				done
			fi	
			echo ""

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to list ASM Disks"
			else
				if [ ${EMCPADM_FORMAT} = LONG ];then

					echo ""
					echo " ${PROG}: Using the following command"
					echo ""
					echo " ssh -q ic-${NODE_NAME} emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
					echo " scp -q ic-${NODE_NAME}:/tmp/emcp_info.${NODE_NAME} /tmp"
					echo " emcpadm check_mappings -vf /tmp/emcp_info.${NODE_NAME}"
				fi

				echo ""
				ssh -q ic-${NODE_NAME} rm -f /tmp/emcp_info.${NODE_NAME}
				ssh -q ic-${NODE_NAME} /sbin/emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
				scp -q ic-${NODE_NAME}:/tmp/emcp_info.${NODE_NAME} /tmp
				LOCAL_REMOTE=LOCAL
				EMCPADM_CHECK

				# Display status
				if [ ${DEVICE_MISMATCH} = NO ];then

					${SETCOLOR_GREEN}
					echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
				else
					${SETCOLOR_RED}
					echo "The following device name(s) on ${NODE_NAME} do not match those on ${HOST}"
					${SETCOLOR_NORMAL}

					EMCPADM_LOOP=1
					while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
					do
						# Display $EMCPADM_DIFF data
						echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]}
	
						# Incremnt EMCPADM_LOOP
						let EMCPADM_LOOP=${EMCPADM_LOOP}+1
					done
				fi	
				${SETCOLOR_NORMAL}
				echo ""
			fi
		else
			# ALL

			NODE_NAME=${HOST}
			if [ ${EMCPADM_FORMAT} = LONG ];then

				echo ""
				echo " ${PROG}: Using the following command"
				echo ""
				echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
				echo " emcpadm check_mappings -vf /tmp/emcp_info.${NODE_NAME}"
			fi

			echo ""
			rm -f /tmp/emcp_info.${NODE_NAME}
			emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
			LOCAL_REMOTE=LOCAL
			EMCPADM_CHECK

			# Display status
			if [ ${DEVICE_MISMATCH} = NO ];then
				${SETCOLOR_GREEN}
				echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
			else
				${SETCOLOR_RED}
				echo "The following device name(s) on ${NODE_NAME} do not match those on ${HOST}"
				${SETCOLOR_NORMAL}

				EMCPADM_LOOP=1
				while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
				do
					# Display $EMCPADM_DIFF data
					echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]}

					# Incremnt EMCPADM_LOOP
					let EMCPADM_LOOP=${EMCPADM_LOOP}+1
				done
			fi	
			${SETCOLOR_NORMAL}
			echo ""

			COUNTER=1
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then
					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to check PowerPath device mapping"
					echo ""
				else
					if [ ${EMCPADM_FORMAT} = LONG ];then

						echo ""
						echo " ${PROG}: Using the following command"
						echo ""
						echo " ssh -q ic-${NODE_NAME} emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
						echo " scp -q ic-${NODE_NAME}:/tmp/emcp_info.${NODE_NAME} /tmp"
						echo " emcpadm check_mappings -vf /tmp/emcp_info.${NODE_NAME}"
					fi

					echo ""
					ssh -q ic-${NODE_NAME} rm -f /tmp/emcp_info.${NODE_NAME}
					ssh -q ic-${NODE_NAME} /sbin/emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}
					scp -q ic-${NODE_NAME}:/tmp/emcp_info.${NODE_NAME} /tmp
					EMCPADM_CHECK

					# Display status
					if [ ${DEVICE_MISMATCH} = NO ];then

						${SETCOLOR_GREEN}
						echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
					else
						${SETCOLOR_RED}
						echo "The following device name(s) on ${NODE_NAME} do not match those on ${HOST}"
						${SETCOLOR_NORMAL}
						EMCPADM_LOOP=1
						while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
						do
							# Display $EMCPADM_DIFF data
							echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]}
		
							# Incremnt EMCPADM_LOOP
							let EMCPADM_LOOP=${EMCPADM_LOOP}+1
						done
					fi	
					${SETCOLOR_NORMAL}
					echo ""
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# Import EMC PowerPath device mapping
	# Use the command "emcpadm import_mappings -f /tmp/emcp_info.${NODE_NAME}" 
	# to import the current emcpower device mapping data from $HOST
	elif [ ${STORAGE_FUNCTION} = IMPORT ];then

		FUNCTION=Import
		RESOURCE="PP device mapping"
		BANNER='*****************'
		SET_LOCAL_REMOTE IMPORT
		EMCPADM_FORMAT=SHORT
		rm -f /tmp/emcp_info.${NODE_NAME}
		emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}

		if [ ${LOCAL_REMOTE} = LOCAL ];then

			EMCPADM_CHECK
			if [ ${DEVICE_MISMATCH} = YES ];then

				ANSWER=""
				ASK IMPORT
				echo ""

				if [ "${ANSWER}" = YES ];then

					# Determine if ASM is up
					ASM_CHECK

					# if ASM is down and all emcpower devices have been umounted
					if [ ${ASM_UP} = NO ];then

						echo ""
						echo " ${PROG}: Using the following commands"
						echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
						echo " emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}"
						echo ""
						emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}
						powermt save
						echo ""
					else
						echo ""
						echo "Note: ASM is still running and or emcpower devices still mounted"
						echo "Moving on to determine if emcpower device names to be changed are in use"
						echo "Note: If this check fails, stop ASM on ${NODE_NAME}, umount all emcpower devices and try again"
						echo ""
	
						EMCPADM_LOOP=1
						# Determine if the emcpower devices to be changed are in use
						while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
						do
							# Set EMCPADM_DIFF_LUN
							EMCPADM_DIFF_LUN=`echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]} |
								awk '{print $2}'`
				
							# Incremnt EMCPADM_LOOP
							let EMCPADM_LOOP=${EMCPADM_LOOP}+1
		
							# Confirm EMCPADM_DIFF_LUN is set
							if [ "${EMCPADM_DIFF_LUN}" = "" ];then
	
								echo ""
								echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set"
								exit
							elif [ `echo ${EMCPADM_DIFF_LUN} | grep -c emcpower.` -eq 0 ];then
								echo ""
								echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set properly"
								exit
							fi
		
							# Check to confirm $EMCPADM_DIFF_LUN not in use
							CHECK_EMCPOWER ${EMCPADM_DIFF_LUN}
						done
		
						# Confirm $EMCPOWER_USED is set to NO
						if [ ${EMCPOWER_USED} = YES ];then
			
							echo ""
							echo " Note: One or more emcpower devices to be imported are in use on ${HOST}, unable to import PowerPath device mapping"
							echo ""
						else
							echo ""
							echo " ${PROG}: Using the following commands"
							echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
							echo " emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}"
							echo ""
							emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}
							powermt save
							echo ""
						fi
					fi
				fi

			elif [ ${DEVICE_MISMATCH} = NO ];then

				echo ""
				echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
				echo "No devices to import !!!"
				echo ""
			fi

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			REMOTE_UP ${NODE_NAME}

			if [ ${UP_DOWN} = DOWN ];then

				echo ""
				echo " Note: Remote node ${NODE_NAME} is down, unable to sync PowerPath device mapping"
				echo ""
			else
				scp -q /tmp/emcp_info.${HOST} ic-${NODE_NAME}:/tmp
				EMCPADM_CHECK
				if [ ${DEVICE_MISMATCH} = YES ];then

					ANSWER=""
					ASK IMPORT
					echo ""

					if [ "${ANSWER}" = YES ];then

						# Determine if ASM is up
						ASM_CHECK

						# if ASM is down and all emcpower devices have been umounted
						if [ ${ASM_UP} = NO ];then

							echo ""
							echo " ${PROG}: Using the following commands"
							echo ""
							echo " emcpadm export_mappings -f /tmp/emcp_info.${HOST}"
							echo " scp -q /tmp/emcp_info.${HOST} ic-${NODE_NAME}:/tmp"
							echo " ssh -q ic-${NODE_NAME} emcpadm import_mappings -vf /tmp/emcp_info.${HOST}"
							echo ""
							ssh -q ic-${NODE_NAME} /sbin/emcpadm import_mappings -vf /tmp/emcp_info.${HOST}
							ssh -q ic-${NODE_NAME} /sbin/powermt save
							echo ""
						else
							echo ""
							echo "Note: ASM is still running and or emcpower devices still mounted"
							echo "Moving on to determine if emcpower device names to be changed are in use"
							echo "Note: If this check fails, stop ASM on ${NODE_NAME}, umount all emcpower devices and try again"
							echo ""
	
							EMCPADM_LOOP=1
							# Determine if the emcpower devices to be changed are in use
							while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
							do
								# Set EMCPADM_DIFF_LUN
								EMCPADM_DIFF_LUN=`echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]} |
									awk '{print $2}'`
					
								# Incremnt EMCPADM_LOOP
								let EMCPADM_LOOP=${EMCPADM_LOOP}+1
			
								# Confirm EMCPADM_DIFF_LUN is set
								if [ "${EMCPADM_DIFF_LUN}" = "" ];then
	
									echo ""
									echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set"
									exit
								elif [ `echo ${EMCPADM_DIFF_LUN} | grep -c emcpower.` -eq 0 ];then
	
									echo ""
									echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set properly"
									exit
								fi
			
								# Check to confirm $EMCPADM_DIFF_LUN not in use
								CHECK_EMCPOWER ${EMCPADM_DIFF_LUN}
							done
	
							# Confirm $EMCPOWER_USED is set to NO
							if [ ${EMCPOWER_USED} = YES ];then
			
								echo ""
								echo " Note: One or more emcpower devices to be imported are in use on ${NODE_NAME}, unable to import PowerPath device mapping"
								echo ""
							else
								echo ""
								echo " ${PROG}: Using the following commands"
								echo ""
								echo " emcpadm export_mappings -f /tmp/emcp_info.${HOST}"
								echo " scp -q /tmp/emcp_info.${HOST} ic-${NODE_NAME}:/tmp"
								echo " ssh -q ic-${NODE_NAME} emcpadm import_mappings -vf /tmp/emcp_info.${HOST}"
								echo ""
								ssh -q ic-${NODE_NAME} /sbin/emcpadm import_mappings -vf /tmp/emcp_info.${HOST}
								ssh -q ic-${NODE_NAME} /sbin/powermt save
								echo ""
							fi
						fi
					fi
				else
					echo ""
					echo "All device names on ${HOST} match the devices on ${NODE_NAME}"
					echo "No devices to import !!!"
					echo ""
				fi
			fi
		else
			# ALL

			NODE_NAME=${HOST}
			LOCAL_REMOTE=LOCAL
			EMCPADM_CHECK

			if [ ${DEVICE_MISMATCH} = YES ];then

				ANSWER=""
				ASK IMPORT
				echo ""

				if [ "${ANSWER}" = YES ];then

					# Determine if ASM is up
					ASM_CHECK

					# if ASM is down and all emcpower devices have been umounted
					if [ ${ASM_UP} = NO ];then

						echo ""
						echo " ${PROG}: Using the following commands"
						echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
						echo " emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}"
						echo ""
						emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}
						powermt save
						echo ""
					else
						echo ""
						echo "Note: ASM is still running and or emcpower devices still mounted"
						echo "Moving on to determine if emcpower device names to be changed are in use"
						echo "Note: If this check fails, stop ASM on ${NODE_NAME}, umount all emcpower devices and try again"
						echo ""
	
						EMCPADM_LOOP=1
						# Determine if the emcpower devices to be changed are in use
						while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
						do
							# Set EMCPADM_DIFF_LUN
							EMCPADM_DIFF_LUN=`echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]} |
								awk '{print $2}'`
				
							# Incremnt EMCPADM_LOOP
							let EMCPADM_LOOP=${EMCPADM_LOOP}+1
		
							# Confirm EMCPADM_DIFF_LUN is set
							if [ "${EMCPADM_DIFF_LUN}" = "" ];then
	
								echo ""
								echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set"
								exit
							elif [ `echo ${EMCPADM_DIFF_LUN} | grep -c emcpower.` -eq 0 ];then
	
								echo ""
								echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set properly"
								exit
							fi
		
							# Check to confirm $EMCPADM_DIFF_LUN not in use
							CHECK_EMCPOWER ${EMCPADM_DIFF_LUN}
						done
		
						# Confirm $EMCPOWER_USED is set to NO
						if [ ${EMCPOWER_USED} = YES ];then
		
							echo ""
							echo " Note: One or more emcpower devices to be imported are in use on ${NODE_NAME}, unable to import PowerPath device mapping"
							echo ""
						else
							echo ""
							echo " ${PROG}: Using the following commands"
							echo " emcpadm export_mappings -f /tmp/emcp_info.${NODE_NAME}"
							echo " emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}"
							echo ""
							emcpadm import_mappings -vf /tmp/emcp_info.${NODE_NAME}
							powermt save
							echo ""
						fi
					fi
				fi
			else
				echo ""
				echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
				echo "No devices to import !!!"
				echo ""
			fi

			COUNTER=1
			LOCAL_REMOTE=REMOTE
			while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				REMOTE_UP ${NODE_NAME}

				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to sync PowerPath device mapping"
					echo ""
				else
					scp -q /tmp/emcp_info.${HOST} ic-${NODE_NAME}:/tmp
					EMCPADM_CHECK
					if [ ${DEVICE_MISMATCH} = YES ];then

						ANSWER=""
						ASK IMPORT
						echo ""

						if [ "${ANSWER}" = YES ];then

							# Determine if ASM is up
							ASM_CHECK

							# If ASM is down and all emcpower devices have been umounted
							if [ ${ASM_UP} = NO ];then

								echo ""
								echo " ${PROG}: Using the following command"
								echo ""
								echo " scp -q /tmp/emcp_info.${HOST} ic-${NODE_NAME}:/tmp"
								echo " ssh -q ic-${NODE_NAME} emcpadm import_mappings -vf /tmp/emcp_info.${HOST}"
								echo ""
								ssh -q ic-${NODE_NAME} /sbin/emcpadm import_mappings -vf /tmp/emcp_info.${HOST}
								ssh -q ic-${NODE_NAME} /sbin/powermt save
								echo ""
							else
								echo ""
								echo "Note: ASM is still running and or emcpower devices still mounted"
								echo "Moving on to determine if emcpower device names to be changed are in use"
								echo "Note: If this check fails, stop ASM on ${NODE_NAME}, umount all emcpower devices and try again"
								echo ""
	
								# Determine if the emcpower devices to be changed are in use
								EMCPADM_LOOP=1
								while [ "${EMCPADM_DIFF[${EMCPADM_LOOP}]}" ]
								do
									# Set EMCPADM_DIFF_LUN
									EMCPADM_DIFF_LUN=`echo ${EMCPADM_DIFF[${EMCPADM_LOOP}]} |
										awk '{print $2}'`
						
									# Incremnt EMCPADM_LOOP
									let EMCPADM_LOOP=${EMCPADM_LOOP}+1
				
									# Confirm EMCPADM_DIFF_LUN is set
									if [ "${EMCPADM_DIFF_LUN}" = "" ];then
										echo ""
										echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set"
										exit
									elif [ `echo ${EMCPADM_DIFF_LUN} | grep -c emcpower.` -eq 0 ];then
										echo ""
										echo " Error: The required variable \"EMCPADM_DIFF_LUN\" not set properly"
										exit
									fi
				
									# Check to confirm $EMCPADM_DIFF_LUN not in use
									CHECK_EMCPOWER ${EMCPADM_DIFF_LUN}
								
								done
		
								# Confirm $EMCPOWER_USED is set to NO
								if [ ${EMCPOWER_USED} = YES ];then
				
									echo ""
									echo " Note: One or more emcpower devices to be imported are in use on ${NODE_NAME}, unable to import PowerPath device mapping"
									echo ""
								else
									echo ""
									echo " ${PROG}: Using the following command"
									echo ""
									echo " scp -q /tmp/emcp_info.${HOST} ic-${NODE_NAME}:/tmp"
									echo " ssh -q ic-${NODE_NAME} emcpadm import_mappings -vf /tmp/emcp_info.${HOST}"
									echo ""
									ssh -q ic-${NODE_NAME} /sbin/emcpadm import_mappings -vf /tmp/emcp_info.${HOST}
									ssh -q ic-${NODE_NAME} /sbin/powermt save
									echo ""
								fi
							fi
						fi
					else
						echo ""
						echo "All device names on ${NODE_NAME} match the devices on ${HOST}"
						echo "No devices to import !!!"
						echo ""
					fi
				fi

				# Increment COUNTER
				let COUNTER=${COUNTER}+1
			done
		fi

	# Partition PP device
	elif [ ${STORAGE_FUNCTION} = PARTITION ];then

		LOCAL_REMOTE=LOCAL
		NODE_NAME=${HOST}

		# Create list of PP devices to partition
		# Add all PP devices with no partitions 
		# to the array EMCPOWER_DEVICES
		SELECT_EMCPOWER

		# CONTINUE set to YES means that there are emcpower devices to partition
		if [ ${CONTINUE} = YES ];then

			LOOP=1
			echo ""
			echo " ******************************"
			echo " * Select device to partition *"
			echo " ******************************"
			echo ""
			while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
			do
			
        			# Set EMCPOWER_DEVICE to the 1st field of ${EMCPOWER_DEVICES[${LOOP}]}
        			EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${LOOP}]} | awk '{print $1}'`
			
        			echo " ${LOOP} > ${EMCPOWER_DEVICE}"
			
        			# Increment LOOP
        			let LOOP=${LOOP}+1
			done
	
			EMCPOWER_DEVICE=""
			let LOOP=${LOOP}-1
	
 			# Confirm the selection
 			until [ -n "${EMCPOWER_DEVICE}" ]
 			do
         			echo -n " Enter selection > "
         			read EMCPOWER_DEVICE
			
         			if [ "${EMCPOWER_DEVICE}" = "" ];then
                 			true
			
         			# Confirm EMCPOWER_DEVICE is not quit
         			elif [ `echo ${EMCPOWER_DEVICE} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
                 			exit 0
			
         			# Confirm EMCPOWER_DEVICE is a Number
         			elif [ `echo ${EMCPOWER_DEVICE} | egrep -c '[^0-9]'` -eq 1 ];then
                 			echo " Invalid selection, ${EMCPOWER_DEVICE}"
                 			EMCPOWER_DEVICE=""
                 			sleep 1
                 			echo ""
			
         			# Confirm EMCPOWER_DEVICE is not greater than ${LOOP} and not equal to 0
         			elif [ ${EMCPOWER_DEVICE} -gt ${LOOP} -o ${EMCPOWER_DEVICE} -eq 0 ];then
                 			echo " Invalid selection, ${EMCPOWER_DEVICE}"
                 			EMCPOWER_DEVICE=""
                 			sleep 1
                 			echo ""
         			else
                 			VALID=TRUE
                 			EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMCPOWER_DEVICE}]} |
                         			awk '{print $1}'`
			
                 			# Confirm EMCPOWER_DEVICE is set properly
                 			if [ "${EMCPOWER_DEVICE}" = "" ];then
                         			echo ""
                         			echo " Error: Problem setting the emcpower device name"
                         			exit 1
                 			fi
         			fi
 			done
	
			# Run the emc_part script on each emcpower device in the array $EMCPOWER_DEVICES
			if [ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ];then
	
				LOOP=1
				while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
				do
					# Skip the All-EMCpower-Devices device
					if [ "${EMCPOWER_DEVICES[${LOOP}]}" = All-EMCpower-Devices ];then
	
						# Increment LOOP
						let LOOP=${LOOP}+1
	
					 	continue
					fi
	
					# Confirm Action
					RESOURCE="${EMCPOWER_DEVICES[${LOOP}]}"
					FUNCTION=Partition
					NODE_NAME=${HOST}
					ASK
					if [ "${ANSWER}" = YES ];then
						echo " ${PROG}: Using the following command"
						echo " /stds/admin/bin/emc_part /dev/${RESOURCE}"
						echo ""
						/stds/admin/bin/emc_part /dev/${RESOURCE}
	
						${SETCOLOR_RED}
						echo " Note: You should now run \"sfdisk -R /dev/${RESOURCE}\" on other nodes"
						echo " ${PROG} Storage menu option 11"
						${SETCOLOR_NORMAL}
					fi
	
					# Increment LOOP
					let LOOP=${LOOP}+1
				done
				echo ""
			else
				# Confirm Action
				FUNCTION=Partition
				RESOURCE="${EMCPOWER_DEVICE}"
				NODE_NAME=${HOST}
				ASK
				if [ "${ANSWER}" = YES ];then
					echo " ${PROG}: Using the following command"
					echo " /stds/admin/bin/emc_part /dev/${EMCPOWER_DEVICE}"
					echo ""
					/stds/admin/bin/emc_part /dev/${EMCPOWER_DEVICE}
	
					${SETCOLOR_RED}
					echo " Note: You should now run \"sfdisk -R /dev/${RESOURCE}\" on other nodes"
					echo " ${PROG} Storage menu option 11"
					${SETCOLOR_NORMAL}
				fi
				echo ""
			fi
		fi

	# sfdisk -R /dev/emcpower
	elif [ ${STORAGE_FUNCTION} = SFDISK ];then

		SET_LOCAL_REMOTE
		if [ ${LOCAL_REMOTE} = LOCAL ];then

			# Create list of PP devices to partition
			# Add all PP devices with no partitions 
			# to the array EMCPOWER_DEVICES
			SELECT_EMCPOWER

			# CONTINUE set to YES means that there are emcpower devices to sfdisk
			if [ ${CONTINUE} = YES ];then

				LOOP=1
				echo ""
				echo " **********************************"
				echo " * Select device to run sfdisk on *"
				echo " **********************************"
				echo ""
				while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
				do
				
       					# Set EMCPOWER_DEVICE to the 1st field of ${EMCPOWER_DEVICES[${LOOP}]}
       					EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${LOOP}]} | awk '{print $1}'`
				
       					echo " ${LOOP} > ${EMCPOWER_DEVICE}"
				
       					# Increment LOOP
       					let LOOP=${LOOP}+1
				done
		
				EMCPOWER_DEVICE=""
				let LOOP=${LOOP}-1
		
 				# Confirm the selection
 				until [ -n "${EMCPOWER_DEVICE}" ]
 				do
        				echo -n " Enter selection > "
        				read EMCPOWER_DEVICE
			
        				if [ "${EMCPOWER_DEVICE}" = "" ];then
                				true
			
        				# Confirm EMCPOWER_DEVICE is not quit
        				elif [ `echo ${EMCPOWER_DEVICE} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
                				exit 0
			
        				# Confirm EMCPOWER_DEVICE is a Number
        				elif [ `echo ${EMCPOWER_DEVICE} | egrep -c '[^0-9]'` -eq 1 ];then
                				echo " Invalid selection, ${EMCPOWER_DEVICE}"
                				EMCPOWER_DEVICE=""
                				sleep 1
                				echo ""
			
        				# Confirm EMCPOWER_DEVICE is not greater than ${LOOP} and not equal to 0
        				elif [ ${EMCPOWER_DEVICE} -gt ${LOOP} -o ${EMCPOWER_DEVICE} -eq 0 ];then
                				echo " Invalid selection, ${EMCPOWER_DEVICE}"
                				EMCPOWER_DEVICE=""
                				sleep 1
                				echo ""
        				else
                				VALID=TRUE
                				EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMCPOWER_DEVICE}]} |
                       					awk '{print $1}'`
			
                				# Confirm EMCPOWER_DEVICE is set properly
                				if [ "${EMCPOWER_DEVICE}" = "" ];then
                       					echo ""
                       					echo " Error: Problem setting the emcpower device name"
                       					exit 1
                				fi
        				fi
 				done
		
				# Run sfdisk -R on each emcpower device in the array $EMCPOWER_DEVICES
				if [ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ];then
		
					LOOP=1
					while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
					do
						# Skip the All-EMCpower-Devices device
						if [ "${EMCPOWER_DEVICES[${LOOP}]}" = All-EMCpower-Devices ];then
		
							# Increment LOOP
							let LOOP=${LOOP}+1
		
				 			continue
						fi
		
						# Confirm Action
						RESOURCE="/dev/${EMCPOWER_DEVICES[${LOOP}]}"
						FUNCTION="sfdisk -R"
						ASK
						if [ "${ANSWER}" = YES ];then
							echo " ${PROG}: Using the following command"
							echo " sfdisk -R ${RESOURCE}"
							echo ""
							sfdisk -R ${RESOURCE}
						fi
		
						# Increment LOOP
						let LOOP=${LOOP}+1
					done
					echo ""
				else
					# Confirm Action
					FUNCTION="sfdisk -R"
					RESOURCE="/dev/${EMCPOWER_DEVICE}"
					ASK
					if [ "${ANSWER}" = YES ];then
						echo " ${PROG}: Using the following command"
						echo " sfdisk -R ${RESOURCE}"
						echo ""
						sfdisk -R ${RESOURCE}
					fi
					echo ""
				fi
			fi

		elif [ ${LOCAL_REMOTE} = REMOTE ];then

			# Confirm ${NODE_NAME} is up
			REMOTE_UP ${NODE_NAME}
			if [ ${UP_DOWN} = DOWN ];then
                		echo ""
                 		echo " Note: Remote node ${NODE_NAME} is down"
                 		echo
                 		sleep 1
			else

				# Create list of PP devices to partition
				# Add all PP devices with no partitions 
				# to the array EMCPOWER_DEVICES
				SELECT_EMCPOWER
	
				# CONTINUE set to YES means that there are emcpower devices to sfdisk
				if [ ${CONTINUE} = YES ];then
	
					LOOP=1
					echo ""
					echo " **********************************"
					echo " * Select device to run sfdisk on *"
					echo " **********************************"
					echo ""
					while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
					do
					
        					# Set EMCPOWER_DEVICE to the 1st field of ${EMCPOWER_DEVICES[${LOOP}]}
        					EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${LOOP}]} | awk '{print $1}'`
					
        					echo " ${LOOP} > ${EMCPOWER_DEVICE}"
					
        					# Increment LOOP
        					let LOOP=${LOOP}+1
					done
			
					EMCPOWER_DEVICE=""
					let LOOP=${LOOP}-1
			
 					# Confirm the selection
 					until [ -n "${EMCPOWER_DEVICE}" ]
 					do
         					echo -n " Enter selection > "
         					read EMCPOWER_DEVICE
					
         					if [ "${EMCPOWER_DEVICE}" = "" ];then
                 					true
					
         					# Confirm EMCPOWER_DEVICE is not quit
         					elif [ `echo ${EMCPOWER_DEVICE} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
                 					exit 0
					
         					# Confirm EMCPOWER_DEVICE is a Number
         					elif [ `echo ${EMCPOWER_DEVICE} | egrep -c '[^0-9]'` -eq 1 ];then
                 					echo " Invalid selection, ${EMCPOWER_DEVICE}"
                 					EMCPOWER_DEVICE=""
                 					sleep 1
                 					echo ""
					
         					# Confirm EMCPOWER_DEVICE is not greater than ${LOOP} and not equal to 0
         					elif [ ${EMCPOWER_DEVICE} -gt ${LOOP} -o ${EMCPOWER_DEVICE} -eq 0 ];then
                 					echo " Invalid selection, ${EMCPOWER_DEVICE}"
                 					EMCPOWER_DEVICE=""
                 					sleep 1
                 					echo ""
         					else
                 					VALID=TRUE
                 					EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMCPOWER_DEVICE}]} |
                         					awk '{print $1}'`
					
                 					# Confirm EMCPOWER_DEVICE is set properly
                 					if [ "${EMCPOWER_DEVICE}" = "" ];then
                         					echo ""
                         					echo " Error: Problem setting the emcpower device name"
                         					exit 1
                 					fi
         					fi
 					done
			
					# Run sfdisk -R on each emcpower device in the array $EMCPOWER_DEVICES
					if [ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ];then
			
						LOOP=1
						while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
						do
							# Skip the All-EMCpower-Devices device
							if [ "${EMCPOWER_DEVICES[${LOOP}]}" = All-EMCpower-Devices ];then
			
								# Increment LOOP
								let LOOP=${LOOP}+1
			
					 			continue
							fi
			
							# Confirm Action
							RESOURCE="/dev/${EMCPOWER_DEVICES[${LOOP}]}"
							FUNCTION="sfdisk -R"
							ASK
							if [ "${ANSWER}" = YES ];then
								echo " ${PROG}: Using the following command"
								echo " ssh -q ic-${NODE_NAME} sfdisk -R ${RESOURCE}"
								echo ""
								ssh -q ic-${NODE_NAME} /sbin/sfdisk -R ${RESOURCE}
							fi
			
							# Increment LOOP
							let LOOP=${LOOP}+1
						done
						echo ""
					else
						# Confirm Action
						FUNCTION="sfdisk -R"
						RESOURCE="/dev/${EMCPOWER_DEVICE}"
						ASK
						if [ "${ANSWER}" = YES ];then
							echo " ${PROG}: Using the following command"
							echo " ssh -q ic-${NODE_NAME} sfdisk -R ${RESOURCE}"
							echo ""
							ssh -q ic-${NODE_NAME} /sbin/sfdisk -R ${RESOURCE}
						fi
						echo ""
					fi
				fi
			fi

		elif [ ${LOCAL_REMOTE} = ALL ];then

			LOCAL_REMOTE=LOCAL
			NODE_NAME=${HOST}

			# Create list of PP devices to partition
			# Add all PP devices with no partitions 
			# to the array EMCPOWER_DEVICES
			SELECT_EMCPOWER

			# CONTINUE set to YES means that there are emcpower devices to sfdisk
			if [ ${CONTINUE} = YES ];then

				LOOP=1
				echo ""
				echo " **********************************"
				echo " * Select device to run sfdisk on *"
				echo " **********************************"
				echo ""
				while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
				do
				
       					# Set EMCPOWER_DEVICE to the 1st field of ${EMCPOWER_DEVICES[${LOOP}]}
       					EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${LOOP}]} | awk '{print $1}'`
				
       					echo " ${LOOP} > ${EMCPOWER_DEVICE}"
				
       					# Increment LOOP
       					let LOOP=${LOOP}+1
				done
		
				EMCPOWER_DEVICE=""
				let LOOP=${LOOP}-1
		
 				# Confirm the selection
 				until [ -n "${EMCPOWER_DEVICE}" ]
 				do
        				echo -n " Enter selection > "
        				read EMCPOWER_DEVICE
			
        				if [ "${EMCPOWER_DEVICE}" = "" ];then
                				true
			
        				# Confirm EMCPOWER_DEVICE is not quit
        				elif [ `echo ${EMCPOWER_DEVICE} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
                				exit 0
			
        				# Confirm EMCPOWER_DEVICE is a Number
        				elif [ `echo ${EMCPOWER_DEVICE} | egrep -c '[^0-9]'` -eq 1 ];then
                				echo " Invalid selection, ${EMCPOWER_DEVICE}"
                				EMCPOWER_DEVICE=""
                				sleep 1
                				echo ""
			
        				# Confirm EMCPOWER_DEVICE is not greater than ${LOOP} and not equal to 0
        				elif [ ${EMCPOWER_DEVICE} -gt ${LOOP} -o ${EMCPOWER_DEVICE} -eq 0 ];then
                				echo " Invalid selection, ${EMCPOWER_DEVICE}"
                				EMCPOWER_DEVICE=""
                				sleep 1
                				echo ""
        				else
                				VALID=TRUE
                				EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMCPOWER_DEVICE}]} |
                       					awk '{print $1}'`
			
                				# Confirm EMCPOWER_DEVICE is set properly
                				if [ "${EMCPOWER_DEVICE}" = "" ];then
                       					echo ""
                       					echo " Error: Problem setting the emcpower device name"
                       					exit 1
                				fi
        				fi
 				done
		
				# Run sfdisk -R on each emcpower device in the array $EMCPOWER_DEVICES
				if [ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ];then
		
					LOOP=1
					while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
					do
						# Skip the All-EMCpower-Devices device
						if [ "${EMCPOWER_DEVICES[${LOOP}]}" = All-EMCpower-Devices ];then
		
							# Increment LOOP
							let LOOP=${LOOP}+1
		
				 			continue
						fi
		
						# Confirm Action
						RESOURCE="/dev/${EMCPOWER_DEVICES[${LOOP}]}"
						FUNCTION="sfdisk -R"
						ASK
						if [ "${ANSWER}" = YES ];then
							echo " ${PROG}: Using the following command"
							echo " sfdisk -R ${RESOURCE}"
							echo ""
							sfdisk -R ${RESOURCE}
						fi
		
						# Increment LOOP
						let LOOP=${LOOP}+1
					done
					echo ""
				else
					# Confirm Action
					FUNCTION="sfdisk -R"
					RESOURCE="/dev/${EMCPOWER_DEVICE}"
					ASK
					if [ "${ANSWER}" = YES ];then
						echo " ${PROG}: Using the following command"
						echo " sfdisk -R ${RESOURCE}"
						echo ""
						sfdisk -R ${RESOURCE}
					fi
					echo ""
				fi
			fi

			LOCAL_REMOTE=REMOTE
			COUNTER=1
			while [ "${REMOTE_HOST_NAMES[${COUNTER}]}" ]
			do
		
				# Set NODE_NAME
				NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

				# Increment COUNTER
				let COUNTER=${COUNTER}+1

				# Confirm ${NODE_NAME} is up
				REMOTE_UP ${NODE_NAME}
				if [ ${UP_DOWN} = DOWN ];then
                			echo ""
                 			echo " Note: Remote node ${NODE_NAME} is down"
                 			echo
                 			sleep 1
					continue
				else

					# Create list of PP devices to partition
					# Add all PP devices with no partitions 
					# to the array EMCPOWER_DEVICES
					SELECT_EMCPOWER
	
					# CONTINUE set to YES means that there are emcpower devices to sfdisk
					if [ ${CONTINUE} = YES ];then
		
						LOOP=1
						echo ""
						echo " **********************************"
						echo " * Select device to run sfdisk on *"
						echo " **********************************"
						echo ""
						while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
						do
						
        						# Set EMCPOWER_DEVICE to the 1st field of ${EMCPOWER_DEVICES[${LOOP}]}
        						EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${LOOP}]} | 
								awk '{print $1}'`
						
        						echo " ${LOOP} > ${EMCPOWER_DEVICE}"
						
        						# Increment LOOP
        						let LOOP=${LOOP}+1
						done
				
						EMCPOWER_DEVICE=""
						let LOOP=${LOOP}-1
				
 						# Confirm the selection
 						until [ -n "${EMCPOWER_DEVICE}" ]
 						do
         						echo -n " Enter selection > "
         						read EMCPOWER_DEVICE
						
         						if [ "${EMCPOWER_DEVICE}" = "" ];then
                 						true
						
         						# Confirm EMCPOWER_DEVICE is not quit
         						elif [ `echo ${EMCPOWER_DEVICE} | egrep -c 'q|Q|Quit|QUIT'` -eq 1 ];then
                 						exit 0
						
         						# Confirm EMCPOWER_DEVICE is a Number
         						elif [ `echo ${EMCPOWER_DEVICE} | egrep -c '[^0-9]'` -eq 1 ];then
                 						echo " Invalid selection, ${EMCPOWER_DEVICE}"
                 						EMCPOWER_DEVICE=""
                 						sleep 1
                 						echo ""
						
         						# Confirm EMCPOWER_DEVICE is not greater than ${LOOP} and not equal to 0
         						elif [ ${EMCPOWER_DEVICE} -gt ${LOOP} -o ${EMCPOWER_DEVICE} -eq 0 ];then
                 						echo " Invalid selection, ${EMCPOWER_DEVICE}"
                 						EMCPOWER_DEVICE=""
                 						sleep 1
                 						echo ""
         						else
                 						VALID=TRUE
                 						EMCPOWER_DEVICE=`echo ${EMCPOWER_DEVICES[${EMCPOWER_DEVICE}]} |
                         						awk '{print $1}'`
						
                 						# Confirm EMCPOWER_DEVICE is set properly
                 						if [ "${EMCPOWER_DEVICE}" = "" ];then
                         						echo ""
                         						echo " Error: Problem setting the emcpower device name"
                         						exit 1
                 						fi
         						fi
 						done
				
						# Run sfdisk -R on each emcpower device in the array $EMCPOWER_DEVICES
						if [ ${EMCPOWER_DEVICE} = All-EMCpower-Devices ];then
				
							LOOP=1
							while [ "${EMCPOWER_DEVICES[${LOOP}]}" ]
							do
								# Skip the All-EMCpower-Devices device
								if [ "${EMCPOWER_DEVICES[${LOOP}]}" = All-EMCpower-Devices ];then
				
									# Increment LOOP
									let LOOP=${LOOP}+1
				
					 				continue
								fi
				
								# Confirm Action
								RESOURCE="/dev/${EMCPOWER_DEVICES[${LOOP}]}"
								FUNCTION="sfdisk -R"
								ASK
								if [ "${ANSWER}" = YES ];then
									echo " ${PROG}: Using the following command"
									echo " ssh -q ic-${NODE_NAME} sfdisk -R ${RESOURCE}"
									echo ""
									ssh -q ic-${NODE_NAME} /sbin/sfdisk -R ${RESOURCE}
								fi
				
								# Increment LOOP
								let LOOP=${LOOP}+1
							done
							echo ""
						else
							# Confirm Action
							FUNCTION="sfdisk -R"
							RESOURCE="/dev/${EMCPOWER_DEVICE}"
							ASK
							if [ "${ANSWER}" = YES ];then
								echo " ${PROG}: Using the following command"
								echo " ssh -q ic-${NODE_NAME} sfdisk -R ${RESOURCE}"
								echo ""
								ssh -q ic-${NODE_NAME} /sbin/sfdisk -R ${RESOURCE}
							fi
							echo ""
						fi
					fi
				fi
			done
		fi
	fi
else
	# Start/Stop/Status

# Determine what Resource to Use
###########################################################################
VALID=""
until [ -n "${VALID}" ]
do
	echo ""
	echo ""
	echo " ***************************${BANNER}"
	echo " * Select Resource to ${FUNCTION} *"
	echo " ***************************${BANNER}"
	echo ""
	echo " 1> Instance"
	echo " 2> Listener"
	echo " 3> VIP"
	echo " 4> Everything (Instance, Listener, and VIP on a Single Host)"
	echo " 5> Database"
	echo " 6> CRS  (Cluster Ready Services)"

	RESOURCE=""
	until [ -n "${RESOURCE}" ]
	do
		echo -n " Enter selection > "
		read RESOURCE
	done

	case ${RESOURCE} in

		1) # Instance
		VALID=TRUE
		RESOURCE=Instance
		BANNER="*****${BANNER}"
		SET_LOCAL_REMOTE
		GET_INSTANCE_NAMES
		SET_INSTANCE_NAME
		DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`
		
		# Comfirm operation
		ANSWER=""
		[ ${FUNCTION} = Start -o ${FUNCTION} = Stop ] && ASK ${INSTANCE_NAME}
		if [ "${ANSWER}" != NO ];then

			echo ""
			echo " ${PROG}: Using the following command"
		else
			FUNCTION=SKIP
		fi

		# Start Instance
		if [ ${FUNCTION} = Start ];then

			echo " srvctl start instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
			echo ""
			srvctl start instance -d ${DB_NAME} -i ${INSTANCE_NAME}

		# Stop Instance
		elif [ ${FUNCTION} = Stop ];then

			echo " srvctl stop instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
			echo ""
			srvctl stop instance -d ${DB_NAME} -i ${INSTANCE_NAME}

		# Status Instance
		elif [ ${FUNCTION} = Status ];then

			echo " srvctl status instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
			echo ""
			srvctl status instance -d ${DB_NAME} -i ${INSTANCE_NAME}
		fi
		echo ""
		echo ""
		;;

		2) # Listener
		VALID=TRUE
		RESOURCE=Listener
		BANNER="*****${BANNER}"
		SET_LOCAL_REMOTE
		GET_LISTENER_NAMES
		SET_LISTENER_NAME
		SET_LISTENER_REAL_HOST_NAME
		
		# Comfirm operation
		ANSWER=""
		[ ${FUNCTION} = Start -o ${FUNCTION} = Stop ] && ASK ${LISTENER_NAME}
		if [ "${ANSWER}" != NO ];then
			echo ""
			echo " ${PROG}: Using the following command"
		else
			FUNCTION=SKIP
		fi

		# Start Listener
		if [ ${FUNCTION} = Start ];then

			echo " srvctl start listener -n ${LISTENER_REAL_HOST_NAME} -l ${LISTENER_NAME}"
			echo ""
			srvctl start listener -n ${LISTENER_REAL_HOST_NAME} -l ${LISTENER_NAME}
		# Stop Listener
		elif [ ${FUNCTION} = Stop ];then

			echo " srvctl stop listener -n ${LISTENER_REAL_HOST_NAME} -l ${LISTENER_NAME}"
			echo ""
			srvctl stop listener -n ${LISTENER_REAL_HOST_NAME} -l ${LISTENER_NAME}

		# Status Listener
		elif [ ${FUNCTION} = Status ];then

			if [ "${LISTENER_REAL_HOST_NAME}" = ${HOST} ];then

				echo " lsnrctl status ${LISTENER_NAME}"
				lsnrctl status ${LISTENER_NAME}
			else

				# Confirm ${LISTENER_REAL_HOST_NAME} is up
				REMOTE_UP ${LISTENER_REAL_HOST_NAME}
				if [ ${UP_DOWN} = DOWN ];then

					echo ""
					echo " Note: Remote node ${LISTENER_REAL_HOST_NAME} is down, unable to get Listener Status"
				else
					echo ""
					echo " ssh ic-${LISTENER_REAL_HOST_NAME} lsnrctl status ${LISTENER_NAME}"
					ssh -q ic-${LISTENER_REAL_HOST_NAME} ${GRID_HOME}/bin/lsnrctl status ${LISTENER_NAME}
				fi
			fi

		fi
		echo ""
		echo ""
		;;

		3) # VIP
		VALID=TRUE
		RESOURCE=VIP
		BANNER="****${BANNER}"
		SET_LOCAL_REMOTE
		GET_VIP_NAMES
		SET_VIP_NAME
		[ ${FUNCTION} = Start -o ${FUNCTION} = Stop ] && ASK
		[ "${ANSWER}" = NO ] && FUNCTION=SKIP
		echo ""

		# Start VIP
		if [ ${FUNCTION} = Start ];then

			echo " ${PROG}: Using the following command"
			echo " crs_start ${VIP_NAME}"
			echo ""
			crs_start ${VIP_NAME}
			echo ""

		# Stop VIP
		elif [ ${FUNCTION} = Stop ];then

			echo " ${PROG}: Using the following command"
			echo " crs_stop -f ${VIP_NAME}"
			echo ""
			crs_stop -f ${VIP_NAME}
			echo ""

		# Status VIP
		elif [ ${FUNCTION} = Status ];then

			echo " ${PROG}: Using the following command"
			echo " crsctl status resource ${VIP_NAME}"
			echo ""
			crsctl status resource ${VIP_NAME}
			echo ""

		fi
		;;

		4) # Everything (Instance, Listener, Service and VIP)
		VALID=TRUE
		RESOURCE=Everything
		BANNER="*******${BANNER}"
		SET_LOCAL_REMOTE
		
		# Comfirm operation
		ANSWER=""
		RESOURCE=all
		[ ${FUNCTION} = Start -o ${FUNCTION} = Stop ] && ASK "Resources"
		[ "${ANSWER}" = NO ] && FUNCTION=SKIP
		echo ""

		# Start Everything
		if [ ${FUNCTION} = Start ];then

			if [ ${LOCAL_REMOTE} = LOCAL -o ${LOCAL_REMOTE} = REMOTE ];then

				GET_INSTANCE_NAMES
				GET_LISTENER_NAMES

				[ ${LOCAL_REMOTE} = LOCAL ] && NODE_NAME=${HOST}

				# Confirm ${NODE_NAME} is up
				[ ${LOCAL_REMOTE} = REMOTE ] && REMOTE_UP ${NODE_NAME}
				if [ ${UP_DOWN} = DOWN -a ${LOCAL_REMOTE} = REMOTE ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to start anything"
				else

					NODE_NUMBER=`echo ${NODE_NAME} | sed 's/\(.*\)\([1-9]$\)/\2/'`
					START_INSTANCES ${NODE_NAME}
					echo ""
					START_LISTENERS ${NODE_NAME}
					echo ""
					START_SERVICES ${NODE_NAME}
					echo ""
					START_VIP ${NODE_NAME}
				fi
				echo ""

			elif [ ${LOCAL_REMOTE} = ALL ];then

				# Start local system fist
				LOCAL_REMOTE=LOCAL
				NODE_NAME=${HOST}
				NODE_NUMBER=`echo ${NODE_NAME} | sed 's/\(.*\)\([1-9]$\)/\2/'`

				GET_INSTANCE_NAMES
				GET_LISTENER_NAMES

				echo ""
				START_INSTANCES ${NODE_NAME}
				echo ""
				START_LISTENERS ${NODE_NAME}
				echo ""
				START_SERVICES ${NODE_NAME}
				echo ""
				START_VIP ${NODE_NAME}
				LOCAL_REMOTE=ALL

				COUNTER=1
				while [ ${REMOTE_HOST_NAMES[${COUNTER}]} ]
				do
			
					# Set NODE_NAME
					NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}
					NODE_NUMBER=`echo ${NODE_NAME} | sed 's/\(.*\)\([1-9]$\)/\2/'`

					GET_INSTANCE_NAMES
					GET_LISTENER_NAMES

					# Confirm ${NODE_NAME} is up
					REMOTE_UP ${NODE_NAME}
					if [ ${UP_DOWN} = DOWN -a ${LOCAL_REMOTE} = REMOTE ];then
						echo ""
						echo " Note: Remote node ${NODE_NAME} is down, unable to start anything"
					else

						echo ""
						START_INSTANCES ${NODE_NAME}
						echo ""
						START_LISTENERS ${NODE_NAME}
						echo ""
						START_SERVICES ${NODE_NAME}
						echo ""
						START_VIP ${NODE_NAME}
					fi

					# Increment COUNTER
					let COUNTER=${COUNTER}+1
				done
			fi
			echo ""

		# Stop Everything
		elif [ ${FUNCTION} = Stop ];then

			if [ ${LOCAL_REMOTE} = LOCAL ];then

				STOP_LISTENERS ${HOST}
				echo ""
				STOP_INSTANCES ${HOST}
				
				# Confirm other systems are still up before stopping VIP
				if [ "${LAST_SYSTEM_UP}" != YES ] ;then
					echo ""
					STOP_VIP ${HOST}
				fi

			elif [ ${LOCAL_REMOTE} = REMOTE ];then

				# Confirm ${NODE_NAME} is up
				REMOTE_UP ${NODE_NAME}
				if [ ${UP_DOWN} = DOWN -a ${LOCAL_REMOTE} = REMOTE ];then

					echo ""
					echo " Note: Remote node ${NODE_NAME} is down, unable to start anything"
				else

					STOP_LISTENERS ${NODE_NAME}
					echo ""
					STOP_INSTANCES ${NODE_NAME}
					echo ""
					STOP_VIP ${NODE_NAME}
				fi

			elif [ ${LOCAL_REMOTE} = ALL ];then

				# Stop remote systems first
				LOCAL_REMOTE=REMOTE
				echo ""

				COUNTER=1
				while [ "${REMOTE_HOST_NAMES[${COUNTER}]}" ]
				do
			
					# Set NODE_NAME
					NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}

					# Confirm ${NODE_NAME} is up
					REMOTE_UP ${NODE_NAME}
					if [ ${UP_DOWN} = DOWN -a ${LOCAL_REMOTE} = REMOTE ];then

						echo ""
						echo " Note: Remote node ${NODE_NAME} is down, unable to start anything"
					else

						STOP_LISTENERS ${NODE_NAME}
						echo ""
						STOP_INSTANCES ${NODE_NAME}
						echo ""
						STOP_VIP ${NODE_NAME}
						echo ""
					fi

					# Increment COUNTER
					let COUNTER=${COUNTER}+1
				done

				# Stop local system last
				LOCAL_REMOTE=LOCAL
				NODE_NAME=${HOST}
				STOP_LISTENERS ${NODE_NAME}
				echo ""
				STOP_INSTANCES ${NODE_NAME}
				echo ""
				STOP_VIP ${NODE_NAME}
			fi

		# Status Everything
		elif [ ${FUNCTION} = Status ];then

			GET_INSTANCE_NAMES
			GET_LISTENER_NAMES
			GET_VIP_NAMES

			# Instance Section
			echo " **************************************************"
			echo " *              Status Instance                   *"
			echo " **************************************************"
			echo ""

			# Loop through each INSTANCE_NAME
			LOOP=1
			while [ "${INSTANCE_NAMES[${LOOP}]}" ]
			do
				# Set INSTANCE_NAME and DB_NAME
				INSTANCE_NAME=`echo ${INSTANCE_NAMES[${LOOP}]} | awk '{print $1}'`
				DB_NAME=`echo ${INSTANCE_NAME} | sed 's/\(.*\)\([1-9]$\)/\1/'`

				echo ""
				echo " For \"Instance\" \"${INSTANCE_NAME}\" ${PROG} using the following command"
				echo " srvctl status instance -d ${DB_NAME} -i ${INSTANCE_NAME}"
				echo ""
				srvctl status instance -d ${DB_NAME} -i ${INSTANCE_NAME}

				# Increment LOOP
				let LOOP=${LOOP}+1
			done
			echo ""

			# Listener Section
			echo " **************************************************"
			echo " *              Status Listener                   *"
			echo " **************************************************"
			echo ""

			# Loop through each LISTENER_NAME
			LOOP=1
			while [ "${LISTENER_NAMES[${LOOP}]}" ]
			do
				# Set LISTENER_NAME and NODE_NAME
				LISTENER_NAME=`echo ${LISTENER_NAMES[${LOOP}]} | awk '{print $1}'`
				NODE_NAME=`echo ${LISTENER_NAME} | awk -F_ '{print $3}' |
					tr '[A-Z]' '[a-z]'`
				echo ""
				echo " For \"Listener\" \"${LISTENER_NAME}\" ${PROG} using the following command"
				echo ""
				SET_LISTENER_REAL_HOST_NAME

				if [ "${LISTENER_REAL_HOST_NAME}" = ${HOST} ];then

					echo " lsnrctl status ${LISTENER_NAME}"
					lsnrctl status ${LISTENER_NAME}
				else

					# Confirm ${LISTENER_REAL_HOST_NAME} is up
					REMOTE_UP ${LISTENER_REAL_HOST_NAME}
					if [ ${UP_DOWN} = DOWN ];then

						echo ""
						echo " Note: Remote node ${LISTENER_REAL_HOST_NAME} is down, unable to get Listener Status"
					else
						echo " ssh ic-${LISTENER_REAL_HOST_NAME} lsnrctl status ${LISTENER_NAME}"
						ssh -q ic-${LISTENER_REAL_HOST_NAME} ${GRID_HOME}/bin/lsnrctl status ${LISTENER_NAME}
					fi
				fi

				# Increment LOOP
				let LOOP=${LOOP}+1
			done
			echo ""

			# VIP Section
			echo " **************************************************"
			echo " *              Status VIP                        *"
			echo " **************************************************"
			echo ""

			# Loop through each VIP_NAME
			LOOP=1
			while [ "${VIP_NAMES[${LOOP}]}" ]
			do
				# Set VIP_NAME 
				VIP_NAME=`echo ${VIP_NAMES[${LOOP}]} | awk '{print $1}'`

				echo ""
				echo " For \"${VIP_NAME}\" ${PROG} using the following command"
				echo " crsctl status resource ${VIP_NAME}"
				echo ""
				crsctl status resource ${VIP_NAME}

				# Increment LOOP
				let LOOP=${LOOP}+1
			done

		fi
		echo ""
		echo ""
		;;
	
		5) # DataBase
		VALID=TRUE
		RESOURCE=Database
		BANNER="*****${BANNER}"
		GET_DB_NAMES
		SET_DB_NAME
		NODE_NAME="All Nodes"
		
		# Comfirm operation
		ANSWER=""
		[ ${FUNCTION} = Start -o ${FUNCTION} = Stop ] && ASK ${DB_NAME}
		if [ "${ANSWER}" != NO ];then

			echo ""
			echo " ${PROG}: Using the following command"
		else
			FUNCTION=SKIP
		fi

		# Start DataBase
		if [ ${FUNCTION} = Start ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " srvctl start database -d ${DB_NAME}"
			echo ""
			srvctl start database -d ${DB_NAME}

		# Stop DataBase
		elif [ ${FUNCTION} = Stop ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " srvctl stop database -d ${DB_NAME}"
			echo ""
			srvctl stop database -d ${DB_NAME}

		# Status DataBase
		elif [ ${FUNCTION} = Status ];then

			echo ""
			echo " ${PROG}: Using the following command"
			echo " srvctl status database -d ${DB_NAME}"
			echo ""
			srvctl status database -d ${DB_NAME}
		fi
		echo ""
		echo ""
		;;

		6) # CRS
		RESOURCE=CRS
		VALID=TRUE
		[ ${FUNCTION} != Status ] && SET_LOCAL_REMOTE

		# Start CRS
		if [ ${FUNCTION} = Start ];then
			echo ""
		
			# Comfirm operation
			ANSWER=""
			ASK ""
			if [ "${ANSWER}" = YES ];then

				echo ""
				echo ""
				echo " ${PROG}: Using the following command"

				# Determine if crsctl start should be run locally or not
				if [ ${LOCAL_REMOTE} = LOCAL ];then

					echo " crsctl start crs"
					crsctl start crs
				else

					# Confirm ${NODE_NAME} is up
					REMOTE_UP ${NODE_NAME}
					if [ ${UP_DOWN} = DOWN ];then
						echo ""
						echo " Note: Remote node ${NODE_NAME} is down, unable to ${FUNCTION} CRS"
					else

						echo " ssh ic-${NODE_NAME} crsctl start crs"
						ssh -q ic-${NODE_NAME} "${GRID_HOME}/bin/crsctl start crs"
					fi
				fi

				echo ""
				echo " Wait 30-60 seconds before running ${PROG} again"
				echo ""
				exit
			fi
			echo ""
			echo ""

		# Stop CRS
		elif [ ${FUNCTION} = Stop ];then
		
			# Comfirm operation
			ANSWER=""
			ASK ""
			if [ "${ANSWER}" = YES ];then

				if [ ${LOCAL_REMOTE} = LOCAL ];then

					echo ""
					STOP_CRS ${HOST}
	
				elif [ ${LOCAL_REMOTE} = REMOTE ];then
	
					echo ""
					STOP_CRS ${NODE_NAME}
	
				elif [ ${LOCAL_REMOTE} = ALL ];then
	
					LOCAL_REMOTE=REMOTE
					COUNTER=1
					while [ "${REMOTE_HOST_NAMES[${COUNTER}]}" ]
					do
				
						# Set NODE_NAME
						NODE_NAME=${REMOTE_HOST_NAMES[${COUNTER}]}
	
						echo ""
						STOP_CRS ${NODE_NAME}
	
						# Increment COUNTER
						let COUNTER=${COUNTER}+1
					done
	
					LOCAL_REMOTE=LOCAL
					NODE_NAME=${HOST}
					echo ""
					STOP_CRS ${NODE_NAME}
				fi
			fi
			echo ""

		# Status CRS
		elif [ ${FUNCTION} = Status ];then

			# Ask to display Short or Long format
			VALID=""
 			until [ -n "${VALID}" ]
 			do

				echo ""
				echo ""
				echo " ************************"
				echo " * Select Status Format *"
				echo " ************************"
				echo ""
				echo " 1> Short Format"
				echo " 2> Long Format"

				FORMAT=""
				until [ -n "${FORMAT}" ]
				do
					echo -n " Enter selection > "
					read FORMAT
				done

				case ${FORMAT} in

					1) # CRS Status (Short Format)
					VALID=TRUE
					SET_LOCAL_REMOTE
					GET_LISTENER_NAMES
					GET_INSTANCE_NAMES
					GET_VIP_NAMES
					LIST_INSTANCE_NAMES
					LIST_LISTENER_NAMES
					LIST_SERVICE_NAMES
					LIST_VIP_NAMES
					LIST_CRS_START_STATUS
					echo ""
					;;

					2) # CRS Status (Long Format)
					VALID=TRUE
					echo ""
					echo " ${PROG}: Using the following command"
					echo " crsctl status resource -f" | more
					crsctl status resource -f | more
					echo ""
					;;

					"") true
					;;

					q|Q|quit|Quit)
					exit 0
					;;

					*)
					echo " Invalid selection, ${FORMAT}"
					FORMAT=""
					sleep 1
					;;		
				esac
			done
		fi
		;;

		"") true
		;;

		q|Q|quit|Quit)
		exit 0
		;;

		*) 
		echo " Invalid selection, ${RESOURCE}"
		RESOURCE=""
		sleep 1
		;;
	esac
done

fi # End of test [ ${FUNCTION} = Other ]

# Determine if oractl is needed again
ANSWER=""
until [ -n "${ANSWER}" ]
do
	echo -n " Do you have more work for ${PROG} Y/N > "
	read ANSWER

	case ${ANSWER} in

        	"") # Do Nothing
        	;;

        	Y|y|YES|yes|Yes)
		DONE=NOT_DONE
        	;;

        	q|Q|N|n|NO|no|No) # Exit Now
		DONE=DONE
        	exit 0
        	;;

        	*)
        	echo ""
        	echo " Invalid selection ${ANSWER}"
        	echo ""
        	ANSWER=""
        	sleep 1
		;;
	esac
done

# End of DONE Loop 
done
echo ""
